<?xml version="1.0"?>
<doc>
    <assembly>
        <name>quantum.core</name>
    </assembly>
    <members>
        <member name="P:Quantum.CharacterController2DConfig.GravityStrength">
            <summary>
            Magnitude of the config <see cref="F:Quantum.CharacterController2DConfig.Gravity"/>, cached when the asset is loaded.
            </summary>
        </member>
        <member name="P:Quantum.CharacterController2DConfig.GravityNormalized">
            <summary>
            Normalized <see cref="F:Quantum.CharacterController2DConfig.Gravity"/>, cached when the asset is loaded.
            </summary>
        </member>
        <member name="P:Quantum.CharacterController3DConfig.GravityStrength">
            <summary>
            Magnitude of the config <see cref="F:Quantum.CharacterController3DConfig.Gravity"/>, cached when the asset is loaded.
            </summary>
        </member>
        <member name="P:Quantum.CharacterController3DConfig.GravityNormalized">
            <summary>
            Normalized <see cref="F:Quantum.CharacterController3DConfig.Gravity"/>, cached when the asset is loaded.
            </summary>
        </member>
        <member name="T:Quantum.NavMesh">
            <summary>
            The asset object that contains a Quantum navigation mesh.
            The object loads an additional data file during the <see cref="M:Quantum.NavMesh.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/>.
            This is because of size limitations when loading the data with Unity serialization.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.Name">
            <summary>
            Name of the navmesh. Access the navmesh by name through <see cref="F:Quantum.Map.NavMeshes"/>.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.DataAsset">
            <summary>
            Asset that contains the actual binary navmesh data.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.GridSizeX">
            <summary>
            The navmesh triangles are partitioned by simple 2D grid. This is the number of all cells on the x-axis. Derived from the map values during baking.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.GridSizeY">
            <summary>
            The number of all grid cells on the y-axis. Derived from the map values during baking.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.GridNodeSize">
            <summary>
            The number of units one grid cell has in both dimensions. Minimum 2. Must be an even number. Derived from the map values during baking.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.WorldOffset">
            <summary>
            The center of the map is the origin. The world offset represents the lower left corner and is copied from <see cref="T:Quantum.Map"/> during the navmesh baking.
            </summary>
            <remarks>WorldOffset.X = -(GridSizeX * GridNodeSize) / 2</remarks>
        </member>
        <member name="F:Quantum.NavMesh.MinAgentRadius">
            <summary>
            The smallest agent radius that the navmesh was created for (to pass visually nicely around the corners).
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.Triangles">
            <summary>
            Navmesh triangles.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.TrianglesGrid">
            <summary>
            Per grid cell data structure that holds all indices to triangles inside this cell.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.Vertices">
            <summary>
            Navmesh vertices referenced by triangles.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.BorderGrid">
            <summary>
            Per grid cell data structure that holds all indices to borders inside this cell.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.TrianglesCenterGrid">
            <summary>
            Per grid cell data structure that holds one (multiple if regions are used) triangle that is somewhat closest to the grid center as a fallback triangle lookup. 
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.Borders">
            <summary>
            Navmesh borders.
            </summary>
        </member>
        <member name="P:Quantum.NavMesh.BorderCount">
            <summary>
            Gets the number of borders.
            </summary>
        </member>
        <member name="M:Quantum.NavMesh.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <summary>
            Checks the <see cref="F:Quantum.NavMesh.DataAsset"/> to load the additional data and runs <see cref="M:Quantum.NavMesh.Serialize(Quantum.ByteStream,System.Boolean)"/> to deserialize the navmesh data.
            </summary>
            <param name="assets">The resource manager to access other assets</param>
            <param name="allocator">The allocator to allocate additional memory for this asset</param>
        </member>
        <member name="M:Quantum.NavMesh.ClampToGrid(Photon.Deterministic.FPVector2@)">
            <summary>
            Clamps the position to be on the grid.
            </summary>
            <param name="position">World position</param>
        </member>
        <member name="M:Quantum.NavMesh.ClampToGrid(Photon.Deterministic.FPVector3@)">
            <summary>
            Clamps the position to be on the grid.
            </summary>
            <param name="position">World position</param>
        </member>
        <member name="M:Quantum.NavMesh.GetHeightAtTriangleRaw(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Returns the y-component of the triangle at point p. Does not check if the point is actually on the XZ-dimensions of the triangle.
            Projects the exact XZ position and does not find the closet position inside the triangle.
            </summary>
            <param name="p">Point to project to triangle</param>
            <param name="normal">Triangle normal</param>
            <param name="v0">Point in triangle</param>
            <returns>Height at point in triangle as raw value.</returns>
        </member>
        <member name="M:Quantum.NavMesh.FindClosestTriangle(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Quantum.NavMeshRegionMask,System.Int32@,Photon.Deterministic.FPVector3@)">
            <summary>
            Finds the closest navmesh triangle at the position plus radius. Works in 2D and 3D. 
            This method sets the mailboxing optimization internally which requires the frame object. Otherwise it's identical to <see cref="M:Quantum.NavMesh.FindClosestTriangle(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Quantum.NavMeshRegionMask,System.Int32@,Photon.Deterministic.FPVector3@,Quantum.MailboxSet8)"/>.
            Caveat: The result is only a heuristic and not 100% accurate due to simplified calculations to reduce precision issues. 
            For example: in 3D the input position is projected down instead of finding the correct closest position.
            The search can be performance heavy so carefully choose the radius.
            </summary>
            <param name="frame">Frame object to locate mailbox memory</param>
            <param name="sourcePosition">Position to start looking</param>
            <param name="radius">Search radius around starting position. Use FP.0 to only search at the exact input position.</param>
            <param name="regionMask">Region mask</param>
            <param name="triangle">The resulting triangle id</param>
            <param name="closestPosition">The corrected source position on the navmesh</param>
            <returns>True when a triangle was found</returns>
        </member>
        <member name="M:Quantum.NavMesh.FindClosestTriangle(Quantum.Core.FrameBase,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Quantum.NavMeshRegionMask,System.Int32@,Photon.Deterministic.FPVector3@)">
            <summary>
            Finds the closest navmesh triangle at the position plus radius. Works in 2D and 3D. 
            This method sets the mailboxing optimization internally which requires the frame object. Otherwise it's identical to <see cref="M:Quantum.NavMesh.FindClosestTriangle(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Quantum.NavMeshRegionMask,System.Int32@,Photon.Deterministic.FPVector3@,Quantum.MailboxSet8)"/>.
            Caveat: The result is only a heuristic and not 100% accurate due to simplified calculations to reduce precision issues. 
            For example: in 3D the input position is projected down instead of finding the correct closest position.
            The search can be performance heavy so carefully choose the radius.
            </summary>
            <param name="frame">Frame object to locate mailbox memory</param>
            <param name="sourcePosition">Position to start looking</param>
            <param name="radius">Search radius around starting position. Use FP.0 to only search at the exact input position.</param>
            <param name="regionMask">Region mask</param>
            <param name="triangle">The resulting triangle id</param>
            <param name="closestPosition">The corrected source position on the navmesh</param>
            <returns>True when a triangle was found</returns>
        </member>
        <member name="M:Quantum.NavMesh.FindClosestTriangle(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Quantum.NavMeshRegionMask,System.Int32@,Photon.Deterministic.FPVector3@,Quantum.MailboxSet8)">
            <summary>
            Finds the closest navmesh triangle at the position plus radius. Works in 2D and 3D.
            Caveat: The result is only a heuristic and not 100% accurate due to simplified calculations to reduce precision issues. 
            For example: in 3D the input position is projected down instead of finding the correct closest position.
            The search can be performance heavy so carefully choose the radius.
            </summary>
            <param name="sourcePosition">Position to start looking</param>
            <param name="radius">Search radius around starting position. Use FP.0 to only search at the exact input position.</param>
            <param name="regionMask">Region mask</param>
            <param name="triangle">The resulting triangle id</param>
            <param name="closestPosition">The corrected source position on the navmesh</param>
            <param name="mailbox">Optionally add a mailbox data structure to optimize the performance of search by filtering out already checked triangles.</param>
            <returns>True when a triangle was found</returns>
        </member>
        <member name="M:Quantum.NavMesh.FindTriangle2D(Photon.Deterministic.FPVector3,Quantum.NavMeshRegionMask,System.Boolean)">
            <summary>
            Finds the triangle at position (X,Z). This will not work in 3D as overlapping triangles may occur. Always use FindClosestTriangle() in 3D.
            </summary>
            <param name="position">Sample position</param>
            <param name="regionMask">Region mask</param>
            <param name="inclusive">Use inclusive true when you want include the border and the vertices of the triangle</param>
            <returns>Triangle id or -1</returns>
        </member>
        <member name="M:Quantum.NavMesh.FindClosestTriangleFast(Photon.Deterministic.FPVector3,Quantum.NavMeshRegionMask)">
            <summary>
            Searches the closest triangle to the input position by using the fallback triangle saved for each grid cell. Result is quite inaccurate.
            </summary>
            <param name="position">Input position</param>
            <param name="regionMask">Triangle regions are checked if they are active</param>
            <returns>True if a triangle was found </returns>
        </member>
        <member name="M:Quantum.NavMesh.FindRandomPointOnTriangle(System.Int32,Photon.Deterministic.RNGSession*,Photon.Deterministic.FPVector3@)">
            <summary>
            Generates a random point on the triangle.
            </summary>
            <param name="triangle">Triangle index. Use FindTriangle() to find the triangle at a position.</param>
            <param name="rngSession">Random number generator usually f->RNG.</param>
            <param name="result">Random position on the triangle or Zero if the triangle does not exists.</param>
        </member>
        <member name="M:Quantum.NavMesh.FindRandomPointOnNavmesh(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Photon.Deterministic.RNGSession*,Quantum.NavMeshRegionMask,Photon.Deterministic.FPVector3@)">
            <summary>
            Tries to find a random position on the navmesh using the input position and radius. This can fail when there is no navmesh in range.
            </summary>
            <param name="position">Center of random position circle</param>
            <param name="radius">Search a random position inside this radius</param>
            <param name="rngSession">The randomization session</param>
            <param name="regionMask">The region mask to check</param>
            <param name="result">The resulting randomized position.</param>
            <returns>True if a position has been found.</returns>
            <remarks>Creates a randomized position first, then tries validate it by finding a triangle at the random position. 
            Then the fallback triangle lookup in <see cref="M:Quantum.NavMesh.FindClosestTriangleFast(Photon.Deterministic.FPVector2,Quantum.NavMeshRegionMask)"/> from the candidate and the original position.
            If all fail, false is returned.
            </remarks>
            <remarks>Processing this offline and saving a custom data structure will probably result in more reliable and appealing results.</remarks>
        </member>
        <member name="M:Quantum.NavMesh.IsBorderActive(System.Int32,Quantum.NavMeshRegionMask)">
            <summary>
            Test if the region of the border at index is enabled.
            </summary>
            <param name="borderIndex">Border index</param>
            <param name="regionMask">Region mask</param>
            <returns>True if region that the border belongs to is active</returns>
        </member>
        <member name="M:Quantum.NavMesh.Contains(Photon.Deterministic.FPVector3,Quantum.NavMeshRegionMask,System.Boolean)">
            <summary>
            Checks if the position is on a navmesh triangle. Does only check the 2D coordinates.
            </summary>
            <param name="position">Position</param>
            <param name="regionMask">Triangle regions are checked if they are active</param>
            <param name="inclusive">Set to true if positions exactly on a triangle edge or border are considered to be inside (default is false)</param>
            <returns>True if the position is on the navmesh</returns>
        </member>
        <member name="M:Quantum.NavMesh.LineOfSight(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.NavMeshRegionMask,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Check line of sight inside the navmesh. This also works in 3D and creates a funnel through the navmesh triangles. Start and destination must be inside the navmesh.
            </summary>
            <param name="positionStart">Start position</param>
            <param name="positionDestination">Target position</param>
            <param name="regionMask">Region mask to identify enabled or disabled regions</param>
            <param name="triangleStart">Optionally provide the triangle that the start position is on</param>
            <param name="triangleDestination">Optionally provide the triangle that the destination position is on</param>
            <param name="considerCost">If the cost changes from triangle to triangle consider this non-line of sight</param>
            <returns>True if there is a unobstructed line of sight on the navmesh</returns>
        </member>
        <member name="M:Quantum.NavMesh.Raycast2D(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.NavMeshRegionMask,Quantum.MailboxSet8,Photon.Deterministic.FPVector2@)">
            <summary>
            Raycast through the navmesh. Only works 2D, even when the navmesh is 3D. The ray is tested against navmesh borders.
            </summary>
            <param name="origin">Ray origin</param>
            <param name="direction">Ray direction</param>
            <param name="distance">Ray length</param>
            <param name="regionMask">Region mask to identify enabled or disabled regions</param>
            <param name="mailbox">Mailbox instance for caching already checked borders, can be null, but then the optimization is not used.</param>
            <param name="hit">Position of the closest hit</param>
            <returns>True is a hit was generated.</returns>
        </member>
        <member name="M:Quantum.NavMesh.MovePositionIntoNavmesh(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.NavMeshRegionMask)">
            <summary>
            This performs a correction of the agent movement against the navmesh borders much like solving physics contacts. This works only in 2D for now.
            Used internally if <see cref="F:Quantum.NavMeshAgentConfig.ClampAgentToNavmesh"/> is set.
            </summary>
            <param name="position">Agent current position</param>
            <param name="newPosition">Agent future position</param>
            <param name="correction">The amount of correction in percent (0..1)</param>
            <param name="regionMask">Region mask to check for active borders</param>
            <returns>Corrected position</returns>
        </member>
        <member name="M:Quantum.NavMesh.MovePositionIntoNavmesh(Quantum.Core.FrameBase,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.NavMeshRegionMask)">
            <summary>
            This performs a correction of the agent movement against the navmesh borders much like solving physics contacts. This works only in 2D for now.
            Used internally if <see cref="F:Quantum.NavMeshAgentConfig.ClampAgentToNavmesh"/> is set.
            </summary>
            <param name="frame">Frame</param>
            <param name="position">Agent current position</param>
            <param name="newPosition">Agent future position</param>
            <param name="correction">The amount of correction in percent (0..1)</param>
            <param name="regionMask">Region mask to check for active borders</param>
            <returns>Corrected position</returns>
        </member>
        <member name="M:Quantum.NavMesh.MovePositionIntoNavmesh(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.NavMeshRegionMask)">
            <summary>
            This performs a correction of the agent movement against the navmesh borders much like solving physics contacts. This works only in 2D for now.
            Used internally if <see cref="F:Quantum.NavMeshAgentConfig.ClampAgentToNavmesh"/> is set.
            </summary>
            <param name="frame">Frame</param>
            <param name="position">Agent current position</param>
            <param name="newPosition">Agent future position</param>
            <param name="correction">The amount of correction in percent (0..1)</param>
            <param name="regionMask">Region mask to check for active borders</param>
            <returns>Corrected position</returns>
        </member>
        <member name="M:Quantum.NavMesh.Serialize(Quantum.ByteStream,System.Boolean)">
            <summary>
            Serializes internal data structures (Triangles, TrianglesGrid, Vertices, BorderGrid, TrianglesCenterGrid, Regions, Borders) from the byte stream.
            Called during <see cref="M:Quantum.NavMesh.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">.</see>
            </summary>
            <param name="stream">Byte stream</param>
            <param name="write">Write or read</param>
        </member>
        <member name="T:Quantum.NavMeshAgentConfig">
            <summary>
            The configuration file for navmesh agent components.
            </summary>
            See <see cref="T:Quantum.NavMeshSteeringAgent"/>
            \ingroup NavigationApi
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.DEFAULT_ID">
            <summary>
            The asset id of the default agent config all agents use when no explicit config is set.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.UpdateInterval">
            <summary>
            The tick interval in which the agent is updated with. The entity index will influence the exact tick the update will happen for each individual entity.
            1 = every tick, 
            2 = every other tick, ..
            For performance reasons different agents will update at different times although they have the same UpdateInterval.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.PathQuality">
            <summary>
            The quality of the A* heuristic function.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.CachedWaypointCount">
            <summary>
            The number of waypoints stored on the agent. Default is 6.
            </summary>
            <remarks>The first waypoint is generated at the position of the agent. The last waypoint is only used during the re-pathing transition as soon as the one before the last waypoint is reached.</remarks>
            <remarks>The value is clamped to a minimum of 3 and a maximum of <see cref="F:Quantum.Navigation.Constants.MaxWaypoints"/></remarks>.
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.MaxRepathTimeout">
            <summary>
            The agent automatically performs path finding again when not having reaching the current waypoint in the given time frame (sec). Set to 0 to disable.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.LineOfSightFunneling">
            <summary>
            This option makes sure that unnecessary waypoints (mostly due to region edges in the proximity) are removed when they are applied to the agent component.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.DynamicLineOfSight">
            <summary>
            This setting will make the agent perform a line cast each tick to skip unnecessary waypoints.
            This is rather expensive try <see cref="F:Quantum.NavMeshAgentConfig.DynamicLineOfSightWaypointRange"/> and <see cref="F:Quantum.NavMeshAgentConfig.LineOfSightFunneling"/> first.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.DynamicLineOfSightWaypointRange">
            <summary>
            This is similar to the DynamicLineOfSight option but only triggers when the agent is in a certain range of the waypoint.\n
            Disabled when set to 0.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AutomaticTargetCorrection">
            <summary>
            When an agent destination is selected that is outside the navmesh and if this option is enabled the target position will automatically tried to be corrected and moved to the inside of the navmesh.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AutomaticTargetCorrectionRadius">
            <summary>
            When setting a target off the navmesh this value defines the radius that is searched to find a valid position.
            0 = only at the target position
            >1 = all cells in radius direction around the target position
            Careful: Searching too many cells can greatly impact the performance.
            If the search fails or the offline generated fallback triangle is used.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.EnableWaypointDetectionAxis">
            <summary>
            When using agent rotation speed the agent sometimes will struggle to detect if a waypoint is reached. Use this value to create an perpendicular testing axis in front of the waypoint.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.WaypointDetectionAxisExtend">
            <summary>
            The extend of the perpendicular axis is WaypointDetectionAxisExtend. Should be something around the double radius of the agent.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.WaypointDetectionAxisOffset">
            <summary>
            The offset toward the previous waypoint set by WaypointDetectionAxisOffset.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.DefaultWaypointDetectionDistance">
            <summary>
            Only required when no steering agent is used. The value used to detect if the agent has reached a waypoint in the beginning of the tick. Set this value to agent max speed * delta time.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.MovementType">
            <summary>
            Select how velocity is applied to the agent component.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.VerticalPositioning">
            <summary>
            Only valid when the agents uses 3D transforms. This defines how it's y-position is calculated. Navmesh is default but it has drawbacks because the navmesh geometry might be too simplified and custom tailored.
            For 3D physics the ground has be created by Quantum colliders.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.Speed">
            <summary>
            The maximum speed of the agent.\n
            The value can be changed during run-time via the agent component.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AngularSpeed">
            <summary>
            The angular speed of the agent (in Radian/sec).\n
            Set to 0 to disable agent rotation.\n
            Set to 200 or more to make its rotation instant-like.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.Acceleration">
            <summary>
            The acceleration of the agent.\n
            When set to 0 no acceleration is used.\n
            The value can be changed during run-time via the agent component.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.StoppingDistance">
            <summary>
            The stopping distance of the agent when approaching the target position.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AutoBraking">
            <summary>
            If active the agent will start breaking when approaching the target.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AutoBrakingDistance">
            <summary>
            The distance from the target when the agents starts to brake. Cannot be changed during run-time because the value is cached.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.ClampAgentToNavmesh">
            <summary>
            Only selectable when <see cref="F:Quantum.NavMeshAgentConfig.MovementType"/> is set to Transform.\n
            The setting makes sure that agents are pushed out of invalid navmesh areas similar to what happens when <see cref="F:Quantum.Navigation.MovementType.DynamicBody"/> is selected and static colliders push the collider out.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.ClampAgentToNavmeshCorrection">
            <summary>
            This is a percentage how much the agent is corrected each tick.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AvoidanceType">
            <summary>
            Select what type of avoidance procedures are applied to the agent. None will disable the active avoidance but other will still be able to avoid the agent. Remove AvoidanceAgent component to completely disable avoidance.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AvoidanceQuality">
            <summary>
            Quality settings for agent avoidance.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.Priority">
            <summary>
            The avoidance priority level.
            </summary>
            <remarks>Most important = 0. Least important = 99. Default = 50.</remarks>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AvoidanceRadius">
            <summary>
            Radius used for avoidance calculation.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AvoidanceLayer">
            <summary>
            Mark agent with a layer to prevent agents from avoiding each other.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AvoidanceMask">
            <summary>
            Other agents whose layer is no in the this mask are ignored.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.MaxAvoidanceCandidates">
            <summary>
            Depending on the quality and number of agents that are influencing each other this value needs to be increased to maintain smooth avoidance.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.ReduceAvoidanceAtWaypoints">
            <summary>
            Activate this to reduce the agent avoidance when getting close to waypoints.
            Use this only if you have kinematic agents to mitigate agents going off the navmesh. 
            An alternative to this is still under development. 
            Try <see cref="F:Quantum.NavMeshAgentConfig.DynamicLineOfSight"/> when using DynamicBodies to mitigate stuck agents on waypoints.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.ReduceAvoidanceFactor">
            <summary>
            This value is multiplied with the agent radius and represents the distance in which the avoidance influence is reduced quadratically.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AvoidanceCanReduceSpeed">
            <summary>
            This option enables velocity candidates that decrease the agents speed, to make the avoidance maneuvers a bit more natural.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.ShowDebugSteering">
            <summary>
            Show agent waypoints and velocity.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.ShowDebugAvoidance">
            <summary>
            Show avoidance information of velocity obstacles and candidates.
            </summary>
        </member>
        <member name="P:Quantum.AssetDB.LoadedAssets">
            <summary>
            All the currently loaded assets.
            </summary>
        </member>
        <member name="M:Quantum.IResourceLoader.LoadResourceAsync(Quantum.AssetResource)">
            <summary>
            Asynchronously loads asset object into resource wrapper (based on resource URL).
            </summary>
            <param name="resource"></param>
        </member>
        <member name="M:Quantum.IResourceLoader.LoadResource(Quantum.AssetResource)">
            <summary>
            Immediately loads asset object into resource wrapper (based on resource URL).
            Blocking call.
            </summary>
            <param name="resource"></param>
        </member>
        <member name="T:Quantum.Core.FrameBase">
            <summary>
             The Frame class is the container for all the transient and static game state data, including the API for entities, physics, assets and others.
            </summary>
            The reason for this is that Systems must be stateless to comply with Quantum's predict/rollback model. Quantum only guarantees determinism if all game state data is fully contained in the Frame class.
            \ingroup FrameClass
            \ingroup EntityApi
        </member>
        <member name="T:Quantum.Core.FrameBase.EntitiesConfig">
            <summary>
            Global entities configuration
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameBase.EntitiesConfig.CommitCommandsMode">
            <summary>
            When "remove component" and "destroy entity" commands should be committed, effectively cleaning and freeing the data from components' buffers.
            <remarks>Both commands still take immediate effect from a semantic perspective, e.g.: checking if the entity exists will return false as soon as the "destroy entity" method is called.</remarks>
            <remarks>Commiting commands on <see cref="F:Quantum.CommitCommandsModes.OnFrameSimulationBegin"/> will ensure that performing Physics Queries is safe, even after the frame simulation ends (from Unity),
            but might result in a larger total amount of memory reserved in case many entities are destroyed AND created in the same frame (analogous for "component removal").</remarks>
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameBase.EntitiesConfig.DefaultEntityCapacity">
            <summary>
            The starting capacity of internal entity and component buffers
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameBase.EntitiesConfig.DefaultComponentBlockCapacity">
            <summary>
            Default value for how many components are stored together in a continuous block of memory 
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameBase.EntitiesConfig.ComponentTypeConfiguration">
            <summary>
            Allows overriding config values on a per-component level
            </summary>
        </member>
        <member name="T:Quantum.Core.FrameBase.FrameBaseUnsafe">
            <summary>
            Frame API to give access to C# unsafe pointers and advanced immediate operations.
            </summary>
            <remarks>Usage: Frame.Unsafe.Get</remarks>
            \ingroup FrameClass
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetComponentBlockIterator``1">
            <summary>
            Get a component iterator that cycles blocks of component pointers.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <returns>Block iterator</returns>
            <example><code>
            var region = 1UL &lt;&lt; 1;
            var navMeshAgents = f.Unsafe.GetComponentBlockIterator&lt;NavMeshAgent&gt;();
            while (navMeshAgents.NextBlock(out EntityRef* entities, out NavMeshAgent* agents, out int count)) {
              for (int i = 0; i&lt;count; i++) {
                var entity = entities[i];
                var agent = &amp;agents[i];
                agent->SetNavMeshRegionActive(region, !agent->IsNavMeshRegionActive(region));
               }
            }
            </code></example>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetComponentBlockIterator``1(System.Int32,System.Int32)">
            <summary>
            Get a component iterator that cycles blocks of component pointers, using a start offset and count
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="offset">Offset of entities we want</param>
            <param name="count">How many entities we want</param>
            <returns>Block iterator</returns>
            <example><code>
            var region = 1UL &lt;&lt; 1;
            var navMeshAgents = f.Unsafe.GetComponentBlockIterator&lt;NavMeshAgent&gt;(32, 16);
            while (navMeshAgents.NextBlock(out EntityRef* entities, out NavMeshAgent* agents, out int count)) {
              for (int i = 0; i&lt;count; i++) {
                var entity = entities[i];
                var agent =  &amp;agents[i];
                agent->SetNavMeshRegionActive(region, !agent->IsNavMeshRegionActive(region));
               }
            }
            </code></example>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetPointer``1(Quantum.EntityRef)">
            <summary>
            Gets a pointer to a component that can be changed directly without writing the component back with <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entityRef">Entity reference</param>
            <returns>Pointer to the requested component</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does not exist</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does have the requested component type.</exception>
            <para>Always check the availability of the component with <see cref="M:Quantum.Core.FrameBase.Has(Quantum.EntityRef,Quantum.ComponentSet)"/> before using this method.</para>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.TryGetPointer``1(Quantum.EntityRef,``0*@)">
            <summary>
            Similar to <see cref="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetPointer``1(Quantum.EntityRef)"/> but does not throw an exception if the component is not present.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entityRef">Entity reference</param>
            <param name="value">Resulting component pointer of null if the component was not found</param>
            <returns>True if component was found</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does not exist</exception>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.CommitAllCommands">
            <summary>
            Trigger the execution of entity and component deletion.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameBase.SetCullable(Quantum.EntityRef,System.Boolean)">
            <summary>
            Sets if an entity is cullable or not
            </summary>
            <param name="entityRef">Entity reference</param>
            <param name="cullable">If the entity should be cullable (true) or not (false)</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.Exists(Quantum.EntityRef)">
            <summary>
            Checks if an entity is still valid.
            </summary>
            For example handy for when you store the entity as a reference inside other components.
            <param name="entityRef">Entity reference</param>
            <returns>True if the entity exists</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.GetComponentIterator``1">
            <summary>
            Create a component iterator for all components of one type.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <returns>Component iterator</returns>
            <remarks>Changed components have to be <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/> back.</remarks>
            <remarks>Accessing the component array creates a copy of the component.</remarks>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Add``1(Quantum.EntityRef,``0)">
            <summary>
            Adds a component to an entity.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entity">Entity reference</param>
            <param name="value">Value of the component to be added</param>
            <remarks>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            </remarks>
            <returns>
            <see cref="F:Quantum.AddResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.AddResult.ComponentAlreadyExists"/> if the <paramref name="entity"/> already has a component of type <typeparamref name="T"/>. The value is not set in this case.
            <see cref="F:Quantum.AddResult.ComponentAdded"/> Otherwise, indicating that the component was successfully added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Add``1(Quantum.EntityRef,``0*@)">
            <summary>
            Adds a component of default value to an entity and returns a pointer to the added component.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entity">Entity reference</param>
            <param name="result">
            A pointer to the component added.
            Null if the result is not <see cref="F:Quantum.AddResult.ComponentAdded"/>.
            </param>
            <remarks>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            </remarks>
            <returns>
            <see cref="F:Quantum.AddResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.AddResult.ComponentAlreadyExists"/> if the <paramref name="entity"/> already has a component of type <typeparamref name="T"/>. The value is not set in this case.
            <see cref="F:Quantum.AddResult.ComponentAdded"/> Otherwise, indicating that the component was successfully added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Add``1(Quantum.EntityRef,``0,``0*@)">
            <summary>
            Adds a component of defined value to an entity and returns a pointer to the added component.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entity">Entity reference</param>
            <param name="value">Value of the component to be added</param>
            <param name="result">
            A pointer to the component added.
            Null if the result is not <see cref="F:Quantum.AddResult.ComponentAdded"/>.
            </param>
            <remarks>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            </remarks>
            <returns>
            <see cref="F:Quantum.AddResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.AddResult.ComponentAlreadyExists"/> if the <paramref name="entity"/> already has a component of type <typeparamref name="T"/>. The value is not set in this case.
            <see cref="F:Quantum.AddResult.ComponentAdded"/> Otherwise, indicating that the component was successfully added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Add(Quantum.EntityRef,System.Int32,System.Void*)">
            <summary>
            Adds a component of defined value to an entity
            </summary>
            <param name="entity">Entity reference</param>
            <param name="componentIndex">
            The index of the component to be added.
            See also <see cref="M:Quantum.ComponentTypeId.GetComponentIndex(System.Type)"/> or <see cref="F:Quantum.ComponentTypeId`1.Id"/> to retrieve the index of a component type.
            </param>
            <param name="value"
            >A pointer to data that should be copied as value to the component added.
            If null, the component is added with default value.
            </param>
            <remarks>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            </remarks>
            <returns>
            <see cref="F:Quantum.AddResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.AddResult.ComponentAlreadyExists"/> if the <paramref name="entity"/> already has a component of index <paramref name="componentIndex"/>. The value is not set in this case.
            <see cref="F:Quantum.AddResult.ComponentAdded"/> Otherwise, indicating that the component was successfully added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Add(Quantum.EntityRef,System.Int32,System.Void*@)">
            <summary>
            Adds a component of default value to an entity and returns a pointer to the added component.
            </summary>
            <param name="entity">Entity reference</param>
            <param name="componentIndex">
            The index of the component to be added.
            See also <see cref="M:Quantum.ComponentTypeId.GetComponentIndex(System.Type)"/> or <see cref="F:Quantum.ComponentTypeId`1.Id"/> to retrieve the index of a component type.
            </param>
            <param name="result">
            A pointer to the component added.
            Null if the result is not <see cref="F:Quantum.AddResult.ComponentAdded"/>.
            </param>
            <remarks>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            </remarks>
            <returns>
            <see cref="F:Quantum.AddResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.AddResult.ComponentAlreadyExists"/> if the <paramref name="entity"/> already has a component of index <paramref name="componentIndex"/>. The value is not set in this case.
            <see cref="F:Quantum.AddResult.ComponentAdded"/> Otherwise, indicating that the component was successfully added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Add(Quantum.EntityRef,System.Int32,System.Void*,System.Void*@)">
            <summary>
            Adds a component of defined value to an entity and returns a pointer to the added component.
            </summary>
            <param name="entity">Entity reference</param>
            <param name="componentIndex">
            The index of the component to be added.
            See also <see cref="M:Quantum.ComponentTypeId.GetComponentIndex(System.Type)"/> or <see cref="F:Quantum.ComponentTypeId`1.Id"/> to retrieve the index of a component type.
            </param>
            <param name="value"
            >A pointer to data that should be copied as value to the component added.
            If null, the component is added with default value.
            </param>
            <param name="result">
            A pointer to the component added.
            Null if the result is not <see cref="F:Quantum.AddResult.ComponentAdded"/>.
            </param>
            <remarks>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">If the <paramref name="componentIndex"/> does not identify a valid component.</exception>
            <returns>
            <see cref="F:Quantum.AddResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.AddResult.ComponentAlreadyExists"/> if the <paramref name="entity"/> already has a component of index <paramref name="componentIndex"/>. The value is not set in this case.
            <see cref="F:Quantum.AddResult.ComponentAdded"/> Otherwise, indicating that the component was successfully added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.AddOrGet``1(Quantum.EntityRef,``0*@)">
            <summary>
            Adds a component of default value to an entity (if it does not have that component yet) and gets a pointer to the component.
            </summary>
            <param name="entity">Entity reference</param>
            <param name="result">
            A pointer to the component added or already existing.
            Null if the <paramref name="entity"/> does not exist.
            </param>
            <returns>False if the entity does not exist and True otherwise.</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.AddOrGet(Quantum.EntityRef,System.Int32,System.Void*@)">
            <summary>
            Adds a component of default value to an entity (if it does not have that component yet) and gets a pointer to the component.
            </summary>
            <param name="entity">Entity reference</param>
            <param name="componentIndex">
            The index of the component to be added.
            See also <see cref="M:Quantum.ComponentTypeId.GetComponentIndex(System.Type)"/> or <see cref="F:Quantum.ComponentTypeId`1.Id"/> to retrieve the index of a component type.
            </param>
            <param name="result">A pointer to the component added or already existing. Null if the <paramref name="entity"/> does not exist.</param>
            <exception cref="T:System.IndexOutOfRangeException">If the <paramref name="componentIndex"/> does not identify a valid component.</exception>
            <returns>False if the entity does not exist and True otherwise.</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)">
            <summary>
            Sets a component on an entity.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entity">Entity ref</param>
            <param name="value">Value of the component to be added</param>
            <returns>
            <see cref="F:Quantum.SetResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.SetResult.ComponentUpdated"/> if the <paramref name="entity"/> already had a component of type <typeparamref name="T"/> that had is value updated to <paramref name="value"/>.
            <see cref="F:Quantum.SetResult.ComponentAdded"/> Otherwise, indicating that a component with the defined value was added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,System.Int32,System.Void*)">
            <summary>
            Sets a component on an entity.
            </summary>
            <param name="entity">Entity ref</param>
            <param name="componentIndex">
            The index of the component being set.
            See also <see cref="M:Quantum.ComponentTypeId.GetComponentIndex(System.Type)"/> or <see cref="F:Quantum.ComponentTypeId`1.Id"/> to get the index of a component.
            </param>
            <param name="value">
            A pointer to data that should be copied as value to the component.
            If null, the component is set with default value.
            </param>
            <exception cref="T:System.IndexOutOfRangeException">If the <paramref name="componentIndex"/> does not identify a valid component.</exception>
            <returns>
            <see cref="F:Quantum.SetResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.SetResult.ComponentUpdated"/> if the <paramref name="entity"/> already had a component of index <paramref name="componentIndex"/> that had is value updated to <paramref name="value"/>.
            <see cref="F:Quantum.SetResult.ComponentAdded"/> Otherwise, indicating that a component with the defined value was added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Get``1(Quantum.EntityRef)">
            <summary>
            Gets a component from an entity.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entityRef">Entity reference</param>
            <returns>Requested component</returns>
            <para>Modified components need to be explicitly written back by using <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>.</para>
            <para>Use <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> to quickly check the entity for component availability.</para>
            <example><code>
            var t = f.Get&lt;Transform2D&gt;(entity);
            t.Position = FPVector2.Zero;
            f.Set(entity, t);
            </code></example>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does not exist</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the component does not exists on entity</exception>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)">
            <summary>
            Checks if an entity has a component.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entityRef">Entity reference</param>
            <returns>True if the component type exists on the entity</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does not exist</exception>
            \ingroup EntityApiT
        </member>
        <member name="M:Quantum.Core.FrameBase.TryGet``1(Quantum.EntityRef,``0@)">
            <summary>
            Gets a component from an entity. Does not throw when the component does not exist.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entityRef">Entity reference</param>
            <param name="value">Requested component</param>
            <returns>True if the component exists</returns>
            <example><code>
            if (f.TryGet&lt;Transform2D&gt;(entity, out Transform2D t)) {
              t.Position = FPVector2.Zero;
              f.Set(entity, t);
            }
            </code></example>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does not exist</exception>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Remove``1(Quantum.EntityRef)">
            <summary>
            Removes a component from an entity.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entityRef">Entity reference</param>
            <returns>False if the <paramref name="entityRef"/> is not valid or the entity does not have a component of type <typeparamref name="T"/>. True otherwise.</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Remove(Quantum.EntityRef,System.Type)">
            <summary>
            Removes a component from an entity.
            </summary>
            <param name="entityRef">Entity reference</param>
            <param name="componentType">Component type</param>
            <returns>False if the <paramref name="entityRef"/> is not valid or the entity does not have a component of type <paramref name="componentType"/>. True otherwise.</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Remove(Quantum.EntityRef,System.Int32)">
            <summary>
            Removes a component from an entity.
            </summary>
            <param name="entityRef">Entity reference</param>
            <param name="componentIndex">The index of the component to be removed.</param>
            <exception cref="T:System.IndexOutOfRangeException">If the <paramref name="componentIndex"/> does not identify a valid component.</exception>
            <returns>False if the <paramref name="entityRef"/> is not valid or the entity does not have a component of index <paramref name="componentIndex"/>. True otherwise.</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.GetComponentSet(Quantum.EntityRef)">
            <summary>
            Gets a set of all component types that were added to the entity.
            </summary>
            <param name="entityRef">Entity reference</param>
            <returns>A set of all component types that are available on the entity</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.TryGetComponentSet(Quantum.EntityRef,Quantum.ComponentSet@)">
            <summary>
            Gets a set of all component types that were added to the entity.
            </summary>
            <param name="entityRef">Entity reference</param>
            <param name="set"></param>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.DestroyPending(Quantum.EntityRef)">
            <summary>
            Check if a destroy is pending for this entity
            </summary>
            <param name="entityRef">Entity reference</param>
            <returns>True of destroy is pending, False otherwise</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.Destroy(Quantum.EntityRef)">
            <summary>
            Destroys the entity and all components that were added to it.
            <remarks>
            The destruction takes immediate effect, i.e., <see cref="M:Quantum.Core.FrameBase.Exists(Quantum.EntityRef)"/> will start to return false.
            The old data, however, will remain in memory until destroy/remove commands are committed,
            according to the <see cref="P:Quantum.Core.FrameBase.CommitCommandsMode"/> or manually through <see cref="M:Quantum.Core.FrameBase.FrameBaseUnsafe.CommitAllCommands"/>.
            </remarks>
            </summary>
            <example><code>f.Destroy(entity);</code></example>
            <param name="entityRef"></param>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Create(Quantum.AssetRefEntityPrototype)">
            <summary>
            Creates an entity from a prototype asset. This process is also reffered to as "prototype materialization".
            </summary>
            <param name="prototype"></param>
            <seealso cref="M:Quantum.Core.FrameBase.Create(Quantum.EntityPrototype)"/>
            <returns></returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Create(Quantum.EntityPrototype)">
            <summary>
            Creates an entity from a prototype. This process is also reffered to as "prototype materialization". 
            </summary>
            The steps are following:
            1. An empty entity is created.
            2. For each component prototype:
              1. Component prototype is materialized.
              2. Component prototype has MaterializeUser invoked.
              3. Component prototype is added to the entity.
            3. <see cref="!:Quantum.ISignalOnEntityPrototypeMaterialized"/> is invoked.
            <param name="prototype"></param>
            <returns></returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Create(Quantum.EntityPrototypeContainer[],Quantum.Map)">
            <summary>
            Creates (materializes) map prototypes. The difference between this method and calling 
            <see cref="M:Quantum.Core.FrameBase.Create(Quantum.EntityPrototype)"/> repeatedly is that <see cref="T:Quantum.EntityRef"/> fields 
            get resolved and that <see cref="T:Quantum.MapEntityLink"/> components are added implicitly.
            </summary>
            This is a multi-step process:
            1. An empty entity is created for each prototype
            2. For each entity-prototype pair:
              1. For each component prototype:
                1. Component prototype is materialized.
                2. Component prototype has MaterializeUser invoked.
                3. Component prototype is added to the entity.
              2. <see cref="T:Quantum.MapEntityLink"/> component is added to the entity.
            3. <see cref="!:ISignalOnEntityPrototypeMaterialized"/> is invoked for each entity-prototype pair.
            <param name="prototypes"></param>
            <param name="parentAsset"></param>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.AssetRefEntityPrototype)">
            <summary>
            Adds (materializes) components to an already existing entity.
            </summary>
            <param name="entity"></param>
            <param name="prototype"></param>
            <returns></returns>
            <see cref="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.EntityPrototype)"/>
        </member>
        <member name="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.EntityPrototype)">
            <summary>
            Adds (materializes) components to an already existing entity. If a component already exists,
            it will get completely overwritten, but an error message will be logged. To avoid errors in
            such case use <see cref="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.EntityPrototype,Quantum.ComponentSet@)"/> instead.
            </summary>
            The steps are following:
            1. For each component prototype:
              1. Component prototype is materialized.
              2. Component prototype has MaterializeUser invoked.
              3. Component prototype is added to the entity.
            2. <see cref="!:Quantum.ISignalOnEntityPrototypeMaterialized"/> is invoked.
            <param name="entity"></param>
            <param name="prototype"></param>
            <returns><see cref="F:Quantum.SetResult.EntityDoesNotExist"/> if entity does not exist. <see cref="F:Quantum.SetResult.ComponentUpdated"/> if any component has been overwritten, <see cref="F:Quantum.SetResult.ComponentAdded"/> otherwise.</returns>
            <seealso cref="M:Quantum.Core.FrameBase.Create(Quantum.EntityPrototype)"/>
            <seealso cref="!:Set(EntityRef, EntityPrototype, out ComponentSet, out ComponentSet)"/>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.AssetRefEntityPrototype,Quantum.ComponentSet@)">
            <summary>
            Adds (materializes) components to an already existing entity.
            </summary>
            <param name="entity"></param>
            <param name="prototype"></param>
            <param name="overwrittenComponents"></param>
            <returns></returns>
            <see cref="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.EntityPrototype,Quantum.ComponentSet@)"/>
        </member>
        <member name="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.EntityPrototype,Quantum.ComponentSet@)">
            <summary>
            Adds (materializes) components to an already existing entity. If a component already exists,
            it will get completely overwritten.
            </summary>
            The steps are following:
            1. For each component prototype:
              1. Component prototype is materialized.
              2. Component prototype has MaterializeUser invoked.
              3. Component prototype is added to the entity.
            2. <see cref="!:Quantum.ISignalOnEntityPrototypeMaterialized"/> is invoked.
            <param name="entity"></param>
            <param name="prototype"></param>
            <param name="overwrittenComponents">Components that have been overwritten.</param>
            <returns><see cref="F:Quantum.SetResult.EntityDoesNotExist"/> if entity does not exist. <see cref="F:Quantum.SetResult.ComponentUpdated"/> if any component has been overwritten, <see cref="F:Quantum.SetResult.ComponentAdded"/> otherwise.</returns>
            <seealso cref="M:Quantum.Core.FrameBase.Create(Quantum.EntityPrototype)"/>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Create">
            <summary>
            Creates an entity that is saved in the game state.
            </summary>
            <returns>Entity reference</returns>
            <example><code>var entity = f.Create();</code></example>
            \ingroup EntityApi
        </member>
        <member name="F:Quantum.Core.FrameBase.Physics2D">
            <summary>
            Access to the Physics2D API.
            </summary>
            \ingroup FrameClass
        </member>
        <member name="F:Quantum.Core.FrameBase.Physics3D">
            <summary>
            Access to the Physics3D API.
            </summary>
            \ingroup FrameClass
        </member>
        <member name="P:Quantum.Core.FrameBase.Navigation">
            <summary>
            Access to the Navigation API.
            </summary>
            \ingroup FrameClass
        </member>
        <member name="M:Quantum.Core.FrameBase.Culled(Quantum.EntityRef)">
            <summary>
            Checks if an entity is culled during prediction
            </summary>
            <param name="entityRef">Entity reference</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.ComponentCount``1">
            <summary>
            Gets the total count of T components
            </summary>
            <typeparam name="T">The component type</typeparam>
            <returns>Total count</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.ComponentCount(System.Int32)">
            <summary>
            Gets the total count of components of a given index.
            See <see cref="T:Quantum.ComponentTypeId"/> and <see cref="T:Quantum.ComponentTypeId`1"/> to have access to component types metadata.
            </summary>
            <param name="componentIndex">The index of the component type</param>
            <returns>Total count</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.Add``1(Quantum.EntityRef)">
            <summary>
            Adds a default component to an entity.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entity">Entity reference</param>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does not exist</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when entity already has a component of the given type</exception>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Has(Quantum.EntityRef,Quantum.ComponentSet)">
            <summary>
            Checks if the entity contains a whole set of components.
            </summary>
            <param name="entityRef">Entity reference</param>
            <param name="set">Set of component types</param>
            <returns>True if the entity has all component types</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.AddAsset(Quantum.AssetObject)">
            <summary>
            Adds a dynamic asset to the frame. 
            Dynamic Asset DB generates and assigns Guids for dynamic assets, so <paramref name="asset"/> can not
            have <see cref="P:Quantum.AssetObject.Guid"/> set before calling this method.
            </summary>
            <param name="asset">Asset object</param>
            <returns>Asset id</returns>
            <example><code>
            PhysicsMaterial material = new PhysicsMaterial {
              Restitution = 1,
              FrictionCombineFunction = PhysicsCombineFunction.Average,
              RestitutionCombineFunction = PhysicsCombineFunction.Average };
            var assetId = f.AddAsset(material);
            </code></example>
        </member>
        <member name="M:Quantum.Core.FrameBase.ReplaceAsset(Quantum.AssetGuid,Quantum.AssetObject)">
            <summary>
            Replaces a dynamic asset in the frame. 
            Asset <paramref name="asset"/> can not have <see cref="P:Quantum.AssetObject.Path"/> or <see cref="P:Quantum.AssetObject.Guid"/>
            set as it inherits both from the original asset.
            </summary>
            <param name="guid">Guid of an asset to be replaced</param>
            <param name="asset">Asset object</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.LoadAsset(Quantum.AssetGuid)">
            <summary>
            Loads an asset asynchronously into memory.
            </summary>
            <param name="guid">Asset guid</param>
            Typically assets are loaded on demand. Use this method to preload assets.
        </member>
        <member name="M:Quantum.Core.FrameBase.DisposeAsset(Quantum.AssetGuid)">
            <summary>
            Disposes an asset.
            </summary>
            <param name="guid">Asset guid</param>
            The actual releasing of the asset is postponed and usually is triggered from the main thread at a later time.
        </member>
        <member name="M:Quantum.Core.FrameBase.DisposeAsset(System.String,Quantum.DatabaseType)">
            <summary>
            Disposes an asset.
            </summary>
            <param name="path">Unique asset path</param>
            <param name="dbType"></param>
            The actual releasing of the asset is postponed and usually is triggered from the main thread at a later time.
        </member>
        <member name="M:Quantum.Core.FrameBase.FindAsset``1(Quantum.AssetGuid)">
            <summary>
            Retrieves an asset either from the asset database or as an dynamic asset. In case of a missing asset
            logs a warning.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="guid">Asset guid</param>
            <returns>Null if guid is not valid or not found, otherwise the requested asset object</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FindAsset``1(Quantum.AssetRef)">
            <summary>
            Retrieves an asset either from the asset database or as an dynamic asset. In case of a missing asset
            logs a warning.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="assetRef">Asset reference</param>
            <returns>Null if reference is not valid or not found, otherwise the requested asset object</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FindAsset``1(Quantum.AssetRef,``0@)">
            <summary>
            Retrieves an asset either from the asset database or as an dynamic asset. In case of a missing asset
            logs a warning.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="assetRef">Asset reference</param>
            <param name="asset">Null if reference is not valid or not found, otherwise the requested asset object.</param>
            <returns>True if guid is valid and an asset is found</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFindAsset``1(Quantum.AssetGuid,``0@)">
            <summary>
            Retrieves an asset either from the asset database or as an dynamic asset.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="guid">Asset guid</param>
            <param name="asset">Null if guid is not valid or not found, otherwise the requested asset object</param>
            <returns>True if guid is valid and an asset is found</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFindAsset``2(``0,``1@)">
            <summary>
            Retrieves an asset either from the asset database or as an dynamic asset.
            </summary>
            <typeparam name="TAssetRef">Asset ref type</typeparam>
            <typeparam name="T">Asset type</typeparam>
            <param name="assetRef">Asset reference</param>
            <param name="asset">Null if reference is not valid or not found, otherwise the requested asset object</param>
            <returns>True if reference is valid and an asset is found</returns>    
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFindAsset``1(Quantum.AssetRef,``0@)">
            <summary>
            Retrieves an asset either from the asset database or as an dynamic asset.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="assetRef">Asset reference</param>
            <param name="asset">Null if reference is not valid or not found, otherwise the requested asset object</param>
            <returns>True if reference is valid and an asset is found</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FindAsset``1(System.String,Quantum.DatabaseType)">
            <summary>
            Retrieves an asset by path from selected databases. In case of a missing asset
            logs a warning.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="path">Unique asset path</param>
            <param name="dbType">Type of the database to look in (AssetDB by default)</param>
            <returns>Null if the asset path can not be found, otherwise the requested asset object</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFindAsset``1(System.String,``0@,Quantum.DatabaseType)">
            <summary>
            Retrieves an asset by path from selected databases.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="path">Unique asset path</param>
            <param name="asset">Null if the path is not valid or not found, otherwise the requested asset object</param>
            <param name="dbType">Type of the database to look in (AssetDB by default)</param>
            <returns>True if the path is valid and an asset is found</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FindPrototype(Quantum.EntityPrototypeRef)">
            <summary>
            
            </summary>
            <param name="prototypeRef"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FindPrototype(Quantum.ComponentPrototypeRef)">
            <summary>
            
            </summary>
            <param name="prototypeRef"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.ClearAllNavMeshRegions">
            <summary>
            If a navmesh region is toggled on/off is saved here. Call this method to reset every region state to be enabled again.
            </summary>
        </member>
        <member name="T:Quantum.Core.CompoundCommand">
            <summary>
            An auxiliary command that can be used to send multiple commands in one. Nested compound commands are accepted.
            </summary>
        </member>
        <member name="F:Quantum.Core.CompoundCommand.Commands">
            <summary>
            A list of the commands that are part of this compound.
            </summary>
        </member>
        <member name="M:Quantum.DispatcherBase.Subscribe``1(System.Object,Quantum.DispatchableHandler{``0},System.Boolean,System.UInt32,Quantum.DispatchableFilter)">
            <summary>
            Creates a subscription. Subscriptions can be cancelled manually by calling <see cref="M:Quantum.DispatcherBase.UnsubscribeHandler``1(Quantum.DispatchableHandler{``0})"/>, but as long
            as the derrived class overrides <see cref="M:Quantum.DispatcherBase.GetListenerStatus(System.Object,System.UInt32)"/> and calls <see cref="M:Quantum.DispatcherBase.RemoveDeadListners"/> periodically, the dispatcher will
            be free of memory leaks.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener">An object listening. A class extending this one decided whether a listener is alive or not in <see cref="M:Quantum.DispatcherBase.GetListenerStatus(System.Object,System.UInt32)"></see></param>
            <param name="handler">Actual event handler.</param>
            <param name="once">Call <paramref name="handler"/> only once.</param>
            <param name="flags">Additional flags. Derriving classes can define their own flags starting with 1 &lt;&lt; <see cref="F:Quantum.DispatcherHandlerFlags.CustomFlagsShift"/> and analyze them in method overrides.</param>
            <param name="filter">Optional event filter. If returns false, handler will not be invoked.</param>
            <returns>Delegate reference that can be stored and used in <see cref="M:Quantum.DispatcherBase.UnsubscribeHandler``1(Quantum.DispatchableHandler{``0})"></see></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.Unsubscribe(Quantum.DispatcherSubscription)">
            <summary>
            Cancel a specific subscription.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.UnsubscribeHandler``1(Quantum.DispatchableHandler{``0})">
            <summary>
            Cancel every subscription using a handler.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.UnsubscribeListener``1(System.Object)">
            <summary>
            Cancel every specific subscription type for a listener.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.SubscribeManual``1(Quantum.DispatchableHandler{``0},System.Boolean,Quantum.DispatchableFilter)">
            <summary>
            Creates a subscription that is active until the caller disposes the result.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="handler"></param>
            <param name="once"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.SubscribeManual``1(System.Object,Quantum.DispatchableHandler{``0},System.Boolean,Quantum.DispatchableFilter)">
            <summary>
            Creates a subscription that is active until the caller disposes the result or calls Unsubscribe.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener"></param>
            <param name="handler"></param>
            <param name="once"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.Clear">
            <summary>
            Removes all subscriptions.
            </summary>
        </member>
        <member name="M:Quantum.DispatcherBase.RemoveDeadListners">
            <summary>
            Removes every subscription for which <see cref="M:Quantum.DispatcherBase.GetListenerStatus(System.Object,System.UInt32)"/> returns <see cref="F:Quantum.DispatcherBase.ListenerStatus.Dead"/>
            </summary>
        </member>
        <member name="M:Quantum.DispatcherBase.UnsubscribeListener(System.Object)">
            <summary>
            Cancel every subscription for a listener.
            </summary>
            <param name="listener"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.SubscribeManualInternal``1(System.Object,System.Int32,Quantum.DispatchableHandler{``0},Quantum.DispatchableFilter,System.Boolean)">
            <summary>
            Creates a subscription that is active until the caller disposes the result.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener"></param>
            <param name="metaIndex"></param>
            <param name="handler"></param>
            <param name="filter"></param>
            <param name="once"></param>
            <returns></returns>
        </member>
        <member name="T:Quantum.EntityRef">
            <summary>
            Quantum entity reference.
            </summary>
            <para>Quantum implements a sparse-set ECS model (similar to enTT). This means entities are just references to collections of components.</para>
            <para>Most important advantages: memory consumption is proportional to instantiated entities + ability to add and remove components dynamically.</para>
            \ingroup EntityApi
        </member>
        <member name="P:Quantum.EntityRef.None">
            <summary>
            The EntityRef value defining a non-existent Entity.
            </summary>
        </member>
        <member name="P:Quantum.EntityRef.IsValid">
            <summary>
            Returns false if this entity is equal to <see cref="P:Quantum.EntityRef.None"/>
            </summary>
        </member>
        <member name="F:Quantum.EntityRef.Index">
            <summary>
            Entity index.
            </summary>
        </member>
        <member name="F:Quantum.EntityRef.Version">
            <summary>
            Entity version is incremented during the entity life cycle when the entity slot is reused.
            </summary>
        </member>
        <member name="T:Quantum.NavMeshPathfinder">
            <summary>
            The NavMeshAgent is an entity component for automated navmesh navigation and steering.
            </summary>
            See also <see cref="T:Quantum.NavMesh"/> and <see cref="T:Quantum.NavMeshAgentConfig"/>
            <example>
            Example method that creates an entity with a transform, a view and a navmesh agent.
            <code>
            private static EntityRef CreateAgent(Frame f, NavMeshAgentConfig config, EntityView view, FPVector2 position) {
              var c = f.Create();
              f.Set(c, new View { Current = view });
              f.Set(c, new Transform2D { Position = position });
              var navMeshAgentConfig = f.FindAsset(config);
              f.Set(c, NavMeshPathfinder.Create(f, c, navMeshAgentConfig));
              f.Set(c, new NavMeshSteeringAgent());
              f.Set(c, new NavMeshAvoidanceAgent());
              return c;
            </code>
            </example>
            \ingroup NavigationApi
        </member>
        <member name="P:Quantum.NavMeshPathfinder.ConfigId">
            <summary>
            Agent config asset.
            </summary>
            <remarks>Use see <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/> to change config during runtime.</remarks>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.InternalTarget">
            <summary>
            Target position is potentially corrected and moved inside the navmesh (read only).
            </summary>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.IsActive">
            <summary>
            The active state of the agent. 
            </summary>
            <remarks>Agent can be active and have no waypoints. That usually means, that the agent will try to find a path during the next tick.</remarks>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.NavMeshGuid">
            <summary>
            Current assigned navmesh.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.Target">
            <summary>
            Input target position set by SetTarget(). (Read Only)
            </summary>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.WaypointIndex">
            <summary>
            The current waypoint the agent steers towards or -1 if there are no stored waypoints.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.WaypointCount">
            <summary>
            The number of waypoints currently stored on the agent. 
            </summary>
            <remarks>The number of waypoints stored can be lower than the actual computed path (for performance reasons during copying the frame memory).</remarks>
            <remarks>The first waypoint is always the agent position when the path finding triggered.</remarks>
            <remarks>The last waypoint is a regular waypoint but a re-pathing is executed when the agent is steering toward it to reduce glitches during path recalculations.</remarks>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.WaypointMaxCount">
            <summary>
            The maximum number of waypoint that can be stored on the agent.
            </summary>
            <remarks>Defined by <see cref="F:Quantum.NavMeshAgentConfig.CachedWaypointCount"/>.</remarks>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.WaypointDetectionDistanceSqr">
            <summary>
            This value is used evaluate if a waypoint is reached and represents the squared distance an agent has traveled during the last tick.
            </summary>
            <remarks>It is automatically set when the entity has <see cref="T:Quantum.NavMeshSteeringAgent"/></remarks>
            <remarks>If not set the config value is used from <see cref="F:Quantum.NavMeshAgentConfig.DefaultWaypointDetectionDistance"/></remarks>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.Create(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig)">
            <summary>
            Use this factory to correctly initialize internals.
            </summary>
            <param name="f">Frame</param>
            <param name="entity">Entity</param>
            <param name="config">Agent config</param>
            <returns>NavMeshPathfinder component that can be Set() on an entity</returns>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.IsOnLink(Quantum.Core.FrameBase)">
            <summary>
            Agent is active and is currently traversing a link.
            </summary>
            <param name="f">Frame</param>
            <returns>True is waypoint is active, agent has waypoints and the current waypoint is a link end</returns>
            <remarks>Its current waypoint has the <see cref="F:Quantum.Navigation.WaypointFlag.LinkEnd"/> flag.</remarks>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.CurrentLink(Quantum.Core.FrameBase)">
            <summary>
            Returns the link that the agent currently is traversing.
            </summary>
            <param name="f">Frame</param>
            <returns>Link index pointing into Navmesh.Links[] or -1</returns>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.CurrentWaypointHasFlag(Quantum.Core.FrameBase,Quantum.Navigation.WaypointFlag)">
            <summary>
            Test the current waypoint for a flag.
            </summary>
            <param name="f">Frame</param>
            <param name="waypointFlag">Flag to test for</param>
            <returns>True if the agent is active, has waypoints and if the current waypoint has the provided flag.</returns>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.GetWaypoint(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Get the waypoint position by waypoint index.
            </summary>
            <param name="f">Frame</param>
            <param name="index">Waypoint index</param>
            <returns>3D waypoint position, zero if waypoint index is not valid</returns>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.GetWaypointFlags(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Access the waypoint flags by index.
            </summary>
            <param name="f">Frame</param>
            <param name="index">Waypoint index (0..MaxWaypoints)</param>
            <returns>Mask of <see cref="T:Quantum.Navigation.WaypointFlag"/></returns>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.GetWaypointLink(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Access the waypoint links by index.
            </summary>
            <param name="f">Frame</param>
            <param name="index">Waypoint index (0..MaxWaypoints)</param>
            <returns>Link index pointing into in Navmesh.Links[] or -1</returns>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)">
            <summary>
            Update the agent config during run-time. Uses the default config (NavMeshAgentConfig.DEFAULT_ID) when config is null.
            </summary>
            <param name="f">Frame</param>
            <param name="entity">Agent entity, required to forward the config to other agent components</param>
            <param name="config">Agent config asset</param>
            <param name="overwrite">Reset properties to their respective config values (e.g. NavMeshSteeringAgent.MaxSpeed, NavMeshAvoidanceAgent.Priority, ..)</param>
            <remarks>Will set the config for <see cref="T:Quantum.NavMeshSteeringAgent"/> and <see cref="T:Quantum.NavMeshAvoidanceAgent"/> components on this entity as well.</remarks>
            <remarks>This can trigger a repath when the waypoint count is changed.</remarks>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.AssetRefNavMeshAgentConfig,System.Boolean)">
            <summary>
            Update the agent config during run-time. Will used NavMeshAgentConfig.DEFAULT_ID if the provided asset ref can not be resolved. Internally calls <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>.
            </summary>
            <param name="f">Frame</param>
            <param name="entity">Agent entity, required to forward the config to other agent components</param>
            <param name="configAssetRef">Asset ref to navmesh config.</param>
            <param name="overwrite">Reset properties to their respective config values (e.g. NavMeshSteeringAgent.MaxSpeed, NavMeshAvoidanceAgent.Priority, ..)</param>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.SetTarget(Quantum.Core.FrameBase,Photon.Deterministic.FPVector3,Quantum.NavMesh)">
            <summary>
            Set agent target position. Does nothing if the target is in <see cref="F:Quantum.NavMeshAgentConfig.StoppingDistance"/> range.
            </summary>
            <param name="f">Frame object</param>
            <param name="target">Target position will be saved as <see cref="P:Quantum.NavMeshPathfinder.Target"/> and clamped to the grid as <see cref="P:Quantum.NavMeshPathfinder.InternalTarget"/></param>
            <param name="navMesh">The navmesh the agent uses during navigation</param>
            <remarks>Will reset the current waypoint list.</remarks>
            <remarks>When the agent is currently on a link, the target position is saved but the waypoints are left intact. The current waypoint is then marked with <see cref="F:Quantum.Navigation.WaypointFlag.RepathWhenReached"/>.</remarks>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.ForceRepath(Quantum.Core.FrameBase)">
            <summary>
            Forces the agent to repath during the next Update(). Reset the waypoints and waypoint index internally.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.Stop(Quantum.Core.FrameBase,Quantum.EntityRef,System.Boolean)">
            <summary>
            Stops the pathfinder agent immediately and disables it and resets its waypoints.
            </summary>
            <param name="f">Frame</param>
            <param name="entity">Requires the entity to check for the SteeringAgent</param>
            <param name="resetVelocity">If true it will check for a SteeringAgent component and set the velocity to zero</param>
        </member>
        <member name="T:Quantum.NavMeshAvoidanceAgent">
            <summary>
            (requires SteeringAgent and PathfinderAgent)
            </summary>
        </member>
        <member name="P:Quantum.NavMeshAvoidanceAgent.AvoidanceMask">
            <summary>
            Agent avoidance mask. Agents with layers outside this mask are ignored.
            </summary>
            <remarks>Is potentially set to its original config value <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>. </remarks>
        </member>
        <member name="P:Quantum.NavMeshAvoidanceAgent.AvoidanceLayer">
            <summary>
            Agent avoidance layer. 
            </summary>
            <remarks>Is potentially set to its original config value <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>. </remarks>
        </member>
        <member name="P:Quantum.NavMeshAvoidanceAgent.Priority">
            <summary>
            The avoidance priority level.
            </summary>
            <remarks>
            <para>Priority (in non-legacy/fast mode) is only compared and split 0.25 and 0.75 between agents (required by reciprocal avoidance).</para>
            <para>Most important = 0</para>
            <para>Least important = 99</para>
            </remarks>
            <remarks>Is potentially set to its original config value <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>. </remarks>
        </member>
        <member name="T:Quantum.Navigation">
            <summary>
            Navigation API
            </summary>
            \ingroup NavigationApi
        </member>
        <member name="T:Quantum.Navigation.VerticalPositioningType">
            <summary>
            Defines how the agents y-position will be calculation in 3D.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.VerticalPositioningType.None">
            <summary>
            Not applied.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.VerticalPositioningType.Navmesh">
            <summary>
            The agents walk on the navmesh.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.VerticalPositioningType.Physics">
            <summary>
            The agents walks on 3D physics geometry.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.MovementType">
            <summary>
            Defines how velocity is applied to the agent component.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.MovementType.None">
            <summary>
            Not applied.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.MovementType.Transform">
            <summary>
            Directly applied to <see cref="T:Quantum.Transform2D"/> or  <see cref="T:Quantum.Transform3D"/> of the agent.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.MovementType.DynamicBody">
            <summary>
            Applied to <see cref="T:Quantum.PhysicsBody2D"/> or <see cref="T:Quantum.PhysicsBody3D"/> as velocity.
            </summary>
            <para>Make sure to set FreezeRotation to true on the agent physics material. This prevents over-steering and other rotation issues with the agent steering.</para>
        </member>
        <member name="F:Quantum.Navigation.MovementType.CharacterController3D">
            <summary>
            Applied to <see cref="T:Quantum.CharacterController2D"/>.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.MovementType.Callback">
            <summary>
            Does not move the agent but executes the MoveAgent signal.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.WaypointFlag">
            <summary>
            Flags stored with each navmesh agent waypoint.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.WaypointFlag.Target">
            <summary>
            The waypoint is the target
            </summary>
        </member>
        <member name="F:Quantum.Navigation.WaypointFlag.LinkStart">
            <summary>
            The waypoint is the start of a off-mesh link
            </summary>
        </member>
        <member name="F:Quantum.Navigation.WaypointFlag.LinkEnd">
            <summary>
            The waypoint is the end of a off-mesh link
            </summary>
        </member>
        <member name="F:Quantum.Navigation.WaypointFlag.RepathWhenReached">
            <summary>
            The agent will perform a repath when reaching the waypoint
            </summary>
        </member>
        <member name="T:Quantum.Navigation.AvoidanceType">
            <summary>
            Avoidance type applied to the navmesh agent.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.AvoidanceType.None">
            <summary>
            Active avoidance disabled. But other agents would still be influenced.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.AvoidanceType.Internal">
            <summary>
            Internal avoidance calculations using velocity obstacle model.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.PathQuality">
            <summary>
            The quality of the A* heuristic function.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.PathQuality.Fast">
            <summary>
            Uses parent G and Manhattan Distance
            </summary>
        </member>
        <member name="F:Quantum.Navigation.PathQuality.Good">
            <summary>
            Creates a pivot point on the entry edge towards goal, recalculates G and Manhattan Distance
            </summary>
        </member>
        <member name="F:Quantum.Navigation.PathQuality.Best">
            <summary>
            Creates a pivot point on the entry edge towards goal, recalculates G with another pivot point towards start and Euclidean Distance
            </summary>
        </member>
        <member name="T:Quantum.Navigation.AvoidanceQuality">
            <summary>
            Quality settings for agent avoidance.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.AvoidanceQuality.Fast">
            <summary>
            Only a minimum of avoidance candidates are computed.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.AvoidanceQuality.Good">
            <summary>
            Reasonable number of candidates are calculated with the best cost-benefit ratio
            </summary>
        </member>
        <member name="F:Quantum.Navigation.AvoidanceQuality.Best">
            <summary>
            Maximum number of collision free candidates are generated
            </summary>
        </member>
        <member name="M:Quantum.Navigation.Dispose">
            <summary>
            Dispose the navigation API.
            </summary>
        </member>
        <member name="M:Quantum.Navigation.Update(Quantum.Core.FrameBase,Photon.Deterministic.FP,Quantum.INavigationCallbacks,Quantum.Task.TaskHandle)">
            <summary>
            Update the multi-threaded navigation API.
            </summary>
            <param name="frame">Frame object</param>
            <param name="deltaTime">Delta time</param>
            <param name="callbacks">Callback object to use (can be null)</param>
            <param name="handle">The task handle to add tasks to</param>
            <returns>Update handle.</returns>
        </member>
        <member name="M:Quantum.Navigation.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.NavMesh,Quantum.NavMeshRegionMask)">
            <summary>
            Find a path (thread-safe). Uses automatic target correction with radius 1 and PathQualtiy Good.
            </summary>
            <param name="frame">Frame object.</param>
            <param name="start">Starting position</param>
            <param name="end">Target position</param>
            <param name="navmesh">The navmesh to operate on</param>
            <param name="regionMask">Region mask is used to check if navmesh parts are active or inactive</param>
            <returns>The corrected start position</returns>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.Navigation.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.NavMesh,Quantum.NavMeshRegionMask,System.Boolean,Photon.Deterministic.FP,Quantum.Navigation.PathQuality)">
            <summary>
            Find a path (thread-safe). 
            </summary>
            <param name="frame">Frame object.</param>
            <param name="start">Starting position</param>
            <param name="end">Target position</param>
            <param name="navmesh">The navmesh to operate on</param>
            <param name="regionMask">Region mask is used to check if navmesh parts are active or inactive</param>
            <param name="automaticTargetCorrection">If the target is outside the navmesh the position will be tried to be corrected.</param>
            <param name="automaticTargetCorrectionRadius">The range to validated the start and target position.</param>
            <param name="quality">The path quality</param>
            <returns>The corrected start position</returns>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.Navigation.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Quantum.NavMesh,Quantum.NavMeshRegionMask)">
            <summary>
            Find a path (thread-safe). 
            </summary>
            <param name="frame">Frame object</param>
            <param name="start">Starting position</param>
            <param name="end">Target position</param>
            <param name="navmesh">The navmesh to operate on</param>
            <param name="regionMask">Region mask is used to check if navmesh parts are active or inactive</param>
            <returns>The corrected start position</returns>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.Navigation.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Quantum.NavMesh,Quantum.NavMeshRegionMask,System.Boolean,Photon.Deterministic.FP,Quantum.Navigation.PathQuality)">
            <summary>
            Find a path (thread-safe). 
            </summary>
            <param name="frame">Frame object</param>
            <param name="start">Starting position</param>
            <param name="end">Target position</param>
            <param name="navmesh">The navmesh to operate on</param>
            <param name="regionMask">Region mask is used to check if navmesh parts are active or inactive</param>
            <param name="automaticTargetCorrection">If the target is outside the navmesh the position will be tried to be corrected.</param>
            <param name="automaticTargetCorrectionRadius">The range to validated the start and target position.</param>
            <param name="quality">The path quality</param>
            <returns>The corrected start position</returns>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.Navigation.LineOfSight(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.NavMeshRegionMask,Quantum.NavMesh,System.Int32,System.Int32)">
            <summary>
            Check line of sight inside the navmesh. This also works in 3D and creates a funnel through the navmesh triangles. Start and destination must be inside the navmesh.
            </summary>
            <param name="positionStart">Start position</param>
            <param name="positionDestination">Target position</param>
            <param name="regionMask">Region mask to identify enabled or disabled regions</param>
            <param name="navmesh">Navmesh to check</param>
            <param name="triangleStart">Optionally provide the triangle that the start position is on</param>
            <param name="triangleDestination">Optionally provide the triangle that the destination position is on</param>
            <returns>True if there is a unobstructed line of sight on the navmesh</returns>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.Navigation.LineOfSight(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Quantum.NavMeshRegionMask,Quantum.NavMesh,System.Int32,System.Int32)">
            <summary>
            Check line of sight inside the navmesh. This also works in 3D and creates a funnel through the navmesh triangles. Start and destination must be inside the navmesh.
            </summary>
            <param name="positionStart">Start position</param>
            <param name="positionDestination">Target position</param>
            <param name="regionMask">Region mask to identify enabled or disabled regions</param>
            <param name="navmesh">Navmesh to check</param>
            <param name="triangleStart">Optionally provide the triangle that the start position is on</param>
            <param name="triangleDestination">Optionally provide the triangle that the destination position is on</param>
            <returns>True if there is a unobstructed line of sight on the navmesh</returns>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.Navigation.Raycast2D(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Quantum.NavMeshRegionMask,Quantum.NavMesh,Photon.Deterministic.FPVector2@)">
            <summary>
            Raycast through the navmesh. Only works 2D, even when the navmesh is 3D. The ray is tested against navmesh borders.
            </summary>
            <param name="frame">Frame object</param>
            <param name="origin">Ray origin</param>
            <param name="direction">Ray direction</param>
            <param name="distance">Ray length</param>
            <param name="regionMask">Region mask to identify enabled or disabled regions</param>
            <param name="navmesh">Navmesh</param>
            <param name="hit">Position of the closest hit</param>
            <returns>True is a hit was generated.</returns>
        </member>
        <member name="M:Quantum.Navigation.Raycast2D(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.NavMeshRegionMask,Quantum.NavMesh,Photon.Deterministic.FPVector2@)">
            <summary>
            Raycast through the navmesh. Only works 2D, even when the navmesh is 3D. The ray is tested against navmesh borders.
            </summary>
            <param name="frame">Frame object</param>
            <param name="origin">Ray origin</param>
            <param name="direction">Ray direction</param>
            <param name="distance">Ray length</param>
            <param name="regionMask">Region mask to identify enabled or disabled regions</param>
            <param name="navmesh">Navmesh</param>
            <param name="hit">Position of the closest hit</param>
            <returns>True is a hit was generated.</returns>
        </member>
        <member name="M:Quantum.Navigation.GetPathFinderData(Quantum.FrameThreadSafe)">
            <summary>
            Access the pathfinder data after running Navigation.FindPath(). Don't save the IPathFinderData object anywhere, copy the data you need.
            </summary>
            <param name="f">Frame object</param>
            <returns>PathFinder data read interface.</returns>
        </member>
        <member name="T:Quantum.Navigation.Config">
            <summary>
            Global navmesh configurations which are part of the <see cref="!:SimulationConfig"/>./>
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.DefaultNavMeshAgent">
            <summary>
            The default navmesh agent config used by every agent that does not set an explicit one.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.EnableNavigationCallbacks">
            <summary>
            Enabled navigation callbacks and signals.
            </summary>
            <remarks>Callbacks are always executed from the main thread.</remarks>
        </member>
        <member name="F:Quantum.Navigation.Config.HeightThresholdForWaypoints">
            <summary>
            Used in 3D to decide weather the actor actor and target are on the same height. Should be around the height of the character.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.HeightThresholdForAvoidance">
            <summary>
            Used in 3D to quickly filter out agents on other height levels. Should be around the height of the character.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.EnableAvoidance">
            <summary>
            A global settings to remove all avoidance task scheduling (disable to optimize for performance).
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.AvoidanceRange">
            <summary>
            Defines the distance between two agents (minus their combined radius) used to determine if they are considering each other for further avoidance calculations (broad phase).
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.MaxAvoidanceCandidates">
            <summary>
            A global setting for the maximum number of avoidance candidates used by each agent. More candidates requires more memory and CPU time but can increase the quality.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.VelocityObstacleTruncationFactor">
            <summary>
             The default factor non-moving velocity obstacles are truncated with.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.Constants">
            <summary>
            Global navigation constants.
            </summary>
            <remarks>Most of the values are kept in static form to enable being set from the outside.</remarks>
            \ingroup NavigationApi
        </member>
        <member name="F:Quantum.Navigation.Constants.PathFinderSize">
            <summary>
            Default number of open nodes for the pathfinder (re-allocated automatically).
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Constants.RawPathSize">
            <summary>
            Maximum size of the raw path generated by the pathfinder.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Constants.ActiveVertexDefaultSize">
            <summary>
            Default number of active nodes the pathfinder works with (re-allocated automatically).
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Constants.FunnelBufferSize">
            <summary>
            The default size of the buffer used for funneling nodes (re-allocated automatically).
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Constants.MaxFunnelPathSize">
            <summary>
            The maximum size of the funneled path.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Constants.MaxRegions">
            <summary>
            The maximum amount of regions per map.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Constants.MaxWaypoints">
            <summary>
            The maximum amount of waypoints that can be stored on a navmesh agent.
            </summary>
            The value set in <see cref="F:Quantum.NavMeshAgentConfig.CachedWaypointCount"/> is clamped to this.
        </member>
        <member name="F:Quantum.Navigation.Constants.MinStoppingDistance">
            <summary>
            Defines the minimum possible stopping distance of an agent.
            </summary>
            <remarks><see cref="F:Quantum.NavMeshAgentConfig.StoppingDistance"/> is clamped to this.</remarks>
        </member>
        <member name="F:Quantum.Navigation.Constants.GenerateFunnelPathNormals">
            <summary>
            Set this to true to generate funnel path normals based on the proximity of borders.
            The option is off by default to save processing power.
            This is a legacy option, the normals are internally not needed anymore.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.PathFinder">
            <summary>
            Navmesh TA* pathfinder class.
            </summary>
        </member>
        <member name="P:Quantum.Navigation.PathFinder.RawPathSize">
            <summary>
            The size of the <see cref="P:Quantum.Navigation.PathFinder.RawPath"/>.
            </summary>
        </member>
        <member name="P:Quantum.Navigation.PathFinder.RawPath">
            <summary>
            The un-funneled raw path.
            </summary>
        </member>
        <member name="M:Quantum.Navigation.PathFinder.#ctor(Photon.Deterministic.Native.Allocator,System.Int32)">
            <summary>
            Create a pathfinder object.
            </summary>
            <param name="allocator">Allocator</param>
            <param name="size">The maximum number of open nodes the A* can work with (usually <see cref="F:Quantum.Navigation.Constants.PathFinderSize"/></param>
        </member>
        <member name="M:Quantum.Navigation.PathFinder.#ctor(Photon.Deterministic.Native.Allocator,Quantum.NavMesh)">
            <summary>
            Create a pathfinder for a certain navmesh.
            </summary>
            <remarks>Uses the triangle count as pathfinder size.</remarks>
            <param name="allocator">Allocator</param>
            <param name="navmesh">Navmesh object</param>
        </member>
        <member name="M:Quantum.Navigation.PathFinder.SetNavMesh(Quantum.NavMesh)">
            <summary>
            Bind a navmesh to a pathfinder.
            </summary>
            <param name="navmesh">Navmesh object</param>
        </member>
        <member name="M:Quantum.Navigation.PathFinder.Dispose">
            <summary>
            Dispose the pathfinder object.
            </summary>
        </member>
        <member name="M:Quantum.Navigation.PathFinder.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Boolean,Photon.Deterministic.FP,Quantum.NavMeshRegionMask,Quantum.Navigation.PathQuality,Quantum.NavMesh)">
            <summary>
            Find path.
            </summary>
            <param name="frame">The frame object.</param>
            <param name="start">Starting position</param>
            <param name="end">Target position</param>
            <param name="automaticTargetCorrection">If the target is outside the navmesh the position will be tried to be corrected.</param>
            <param name="automaticTargetCorrectionRadius">The range of cells used to validated the target position.</param>
            <param name="regionMask">Region mask is used to check if navmesh parts are active or inactive</param>
            <param name="quality">The path quality</param>
            <param name="navmesh">The navmesh to operate on</param>
            <returns>The corrected end position</returns>
        </member>
        <member name="M:Quantum.Navigation.PathFinder.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Boolean,Photon.Deterministic.FP,Quantum.NavMeshRegionMask,Quantum.Navigation.PathQuality,Quantum.NavMesh)">
            <summary>
            See <see cref="M:Quantum.Navigation.PathFinder.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Boolean,Photon.Deterministic.FP,Quantum.NavMeshRegionMask,Quantum.Navigation.PathQuality,Quantum.NavMesh)"/>
            </summary>
        </member>
        <member name="F:Quantum.Navigation.AngularSpeedInstantRotationThreshold">
            <summary>
            We can shortcut the angular acceleration by using this threshold
            </summary>
        </member>
        <member name="T:Quantum.Physics2D.PhysicsEngine2D">
            <summary>
            2D Physics API
            </summary>
        </member>
        <member name="T:Quantum.Physics2D.PhysicsEngine2D.Api">
            <summary>
            2D Physics API
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)">
            <summary>
            Sets which 2D physics collision callbacks will be called for the <paramref name="entity"/>.
            <remarks>The entity must have a PhysicsCollider2D component attached to be able to collide with other physics entries.</remarks>
            <remarks>For receiving the callbacks, set the <see cref="T:Quantum.CallbackFlags"/> and implement the corresponding signal on a system.</remarks>
            </summary>
            <param name="entity">An entity with a PhysicsCollider2D component attached.</param>
            <param name="flags">The <see cref="T:Quantum.CallbackFlags"/> of the desired collision callbacks.</param>
            <code>frame.Physics2D.SetCallbacks(entity, CallbackFlags.OnDynamicCollision | CallbackFlags.OnStaticTriggerEnter);</code>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetCallbacks(Quantum.EntityRef)">
            <summary>
            Get the flags that represent which 2D physics collision callbacks will be called for the <paramref name="entity"/>.
            <remarks>The entity must have a PhysicsCollider2D component attached to be able to collide with other physics entries.</remarks>
            <remarks>To modify the callbacks, use <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            </summary>
            <param name="entity">The entity from which to get the callback flags.</param>
            <returns>The callback flags set to a given entity. Default if the entity did not have callback flags set.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ResetCallbacks(Quantum.EntityRef)">
            <summary>
            Resets the tracking history of collisions the <paramref name="entity"/> might have.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)">
            <summary>
            Allocates a persistent <see cref="T:Quantum.Physics2D.HitCollection"/> on the heap with an initial capacity.
            To free an allocated persistent collection of 2D hits, use <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.FreePersistentHitCollection(Quantum.Physics2D.HitCollection*)"/>.
            </summary>
            <param name="defaultCapacity">The initial <see cref="T:Quantum.Physics2D.Hit"/> buffer capacity allocated for the hit collection.</param>
            <returns>A pointer to the allocated hit collection.</returns>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.FreePersistentHitCollection(Quantum.Physics2D.HitCollection*)">
            <summary>
            Free a persistent <see cref="T:Quantum.Physics2D.HitCollection"/> previously allocated on the heap.
            To allocate a persistent collection of 2D hits, use <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.
            </summary>
            <param name="collection">A pointer to the persistent hit collection to be freed.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the hit collection was not allocated as persistent.</exception>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetQueryHits(System.Int32)">
            <summary>
            Gets the results of a broad-phase query added to the 2D physics scene.
            </summary>
            <param name="index">The broad-phase query index.</param>
            <returns>A <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits.</returns>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.TryGetQueryHits(System.Int32,Quantum.Physics2D.HitCollection@)">
            <summary>
            Tries to get the results of a broad-phase query added to the 2D physics scene.
            </summary>
            <param name="index">The broad-phase query index.</param>
            <param name="queryHits">The <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits. Default if the index is not valid.</param>
            <returns>True if the index is valid, false otherwise.</returns>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetAllQueriesHits(Quantum.Physics2D.HitCollection*@,System.Int32@)">
            <summary>
            Gets all the results for all the broad-phase queries added to the 2D physics scene this frame.
            </summary>
            <param name="queriesHits">A buffer of <see cref="T:Quantum.Physics2D.HitCollection"/> with <paramref name="queriesCount"/> elements, one for each broad-phase query added.</param>
            <param name="queriesCount">The number of elements in the <paramref name="queriesHits"/> buffer, also matching the number on broad-phase queries added.</param>
            <returns>True if at least one broad-phase query has been added from a system that runs before the physics engine.</returns>
            <example>
            Example of how to iterate over added broad-phase queries results.
            <code>
            if (f.Physics2D.GetAllQueriesHits(out var queriesHits, out var queriesCount)) {
              for (var i = 0; i &lt; queriesCount; i++) {
                var queryHits = queriesHits + i;
                Log.Info($"Preemptive query {i} has {queryHits->Count} hits.");
              }
            }
            </code>
            </example>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddShapeCastQuery(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Boolean,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Adds a broad-phase shape cast query to the 2D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="start">The cast start point, in a 2D world space.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="firstHitOnly">If the query results should return only the hit with the smallest <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/> or all hits (default).</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>The index of the injected query, to be used when retrieving the results with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetQueryHits(System.Int32)"/>.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCast(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a shape cast and returns the hit with the shortest <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/>, if any.
            </summary>
            <param name="start">The cast start, in a 2D world space.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A nullable <see cref="T:Quantum.Physics2D.Hit"/> with the smallest <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/>, if any.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCast(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a shape cast and adds the hit with the shortest <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/>, if any, to a persistent collection of hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="start">The cast start, in a 2D world space.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A nullable <see cref="T:Quantum.Physics2D.Hit"/> with the smallest <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/>, if any.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a shape cast, returning all hits.
            </summary>
            <param name="start">The cast start, in a 2D world space.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCastAll(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a shape cast, adding all hits to a persistent collection.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="start">The cast start, in a 2D world space.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddOverlapShapeQuery(Quantum.Transform2D,Quantum.Transform2DVertical,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase shape overlap query to the 2D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="transform">A 2D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="transformVertical">A vertical transform component, with Vertical Position and Height info of the shape overlap on a 2.5D context.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetQueryHits(System.Int32)"/>.</returns>
            <remarks>When using a vertical transform, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddOverlapShapeQuery(Quantum.Transform2D,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase shape overlap query to the 2D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="transform">A 2D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetQueryHits(System.Int32)"/>.</returns>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddOverlapShapeQuery(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Adds a broad-phase shape overlap query to the 2D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="position">The position in which the shape is overlapped.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>The index of the injected query, to be used when retrieving the results with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetQueryHits(System.Int32)"/>.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Physics2D.HitCollection*,Quantum.Transform2D,Quantum.Transform2DVertical,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 2D physics scene with a shape overlap.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="transform">A 2D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="transformVertical">A vertical transform component, with Vertical Position and Height info of the shape overlap on a 2.5D context.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the hit collection is not persistent.</exception>
            <remarks>When using vertical transform, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Physics2D.HitCollection*,Quantum.Transform2D,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 2D physics scene with a shape overlap.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="transform">A 2D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the hit collection is not persistent.</exception>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a shape overlap.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="position">The position in which the shape is overlapped.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the hit collection is not persistent.</exception>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Transform2D,Quantum.Transform2DVertical,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 2D physics scene with a shape overlap.
            </summary>
            <param name="transform">A 2D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="transformVertical">A vertical transform component, with Vertical Position and Height info of the shape overlap on a 2.5D context.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            <remarks>When using vertical transform, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Transform2D,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 2D physics scene with a shape overlap.
            </summary>
            <param name="transform">A 2D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a shape overlap.
            </summary>
            <param name="position">The position in which the shape is overlapped.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ResetMap">
            <summary>
            Resets 2D physics scene map asset guid.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="P:Quantum.Physics2D.PhysicsEngine2D.Api.Map">
            <summary>
            Retrieves the map asset currently used on the physics scene.
            <remarks>
            The map currently used by the physics scene is only updated during verified simulations,
            so this map can be different from the frame Map during predictions, when the latter is changed. 
            </remarks>
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.Print(Quantum.FramePrinter)">
            <summary>
            Prints the 2D Physics Engine state on the provided frame <paramref name="printer"/>.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddRaycastQuery(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Boolean,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Adds a broad-phase raycast query to the 2D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="origin">The ray origin point, in a 2D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="firstHitOnly">If the query results should return only the closest hit to the ray <paramref name="origin"/> or all hits (default).</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>The index of the injected query, to be used when retrieving the results with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetQueryHits(System.Int32)"/>.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddLinecastQuery(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Boolean,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Adds a broad-phase line cast query to the 2D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="start">The line start point, in a 2D world space.</param>
            <param name="end">The line end point, in a 2D world space.</param>
            <param name="firstHitOnly">If the query results should return only the closest hit to the line <paramref name="start"/> or all hits (default).</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>The index of the injected query, to be used when retrieving the results with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetQueryHits(System.Int32)"/>.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.Raycast(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a ray cast and returns the closest hit to the ray origin, if any.
            </summary>
            <param name="origin">The ray origin point, in a 2D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A nullable <see cref="T:Quantum.Physics2D.Hit"/> with the closest hit to the ray origin, if any.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.Raycast(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a ray cast and adds the closest hit to the ray origin, if any, to a persistent collection of hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="origin">The ray origin point, in a 2D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.Linecast(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a line cast and returns the closest hit to the line start, if any.
            </summary>
            <param name="start">The line start point, in a 2D world space.</param>
            <param name="end">The line end point, in a 2D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A nullable <see cref="T:Quantum.Physics2D.Hit"/> with the closest hit to the line start, if any.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.Linecast(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a line cast and adds the closest hit to the line start, if any, to a persistent collection of hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="start">The line start point, in a 2D world space.</param>
            <param name="end">The line end point, in a 2D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.RaycastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a ray cast, returning all hits.
            </summary>
            <param name="origin">The ray origin point, in a 2D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.RaycastAll(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a ray cast, adding all hits to a persistent collection.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="origin">The ray origin point, in a 2D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.LinecastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a line cast, returning all hits.
            </summary>
            <param name="start">The line start point, in a 2D world space.</param>
            <param name="end">The line end point, in a 2D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.LinecastAll(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a line cast, adding all hits to a persistent collection.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="start">The line start point, in a 2D world space.</param>
            <param name="end">The line end point, in a 2D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.SetStaticColliderEnabled(System.Int32,System.Boolean)">
            <summary>
            Set a toggleable 2D static collider enabled state to <paramref name="enabled"/>.
            Disabled static colliders are not considered for collisions or on query resolutions.
            <remarks>The static collider state is only changed on Verified frames.</remarks>
            </summary>
            <param name="staticColliderIndex">The index of the collider in the Map <see cref="F:Quantum.Map.StaticColliders2D">StaticColliders2D</see> array.</param>
            <param name="enabled">If the static should be enabled (true) or disabled (false).</param>
            <exception cref="T:System.InvalidOperationException">If the static collider is baked as Immutable.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the provided <paramref name="staticColliderIndex"/> is not in the range of static colliders loaded in the current Physics static scene.</exception>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.IsStaticColliderEnabled(System.Int32)">
            <summary>
            Returns the current state of a 2D static collider.
            </summary>
            <param name="staticColliderIndex">The index of the collider in the Map <see cref="F:Quantum.Map.StaticColliders2D">StaticColliders2D</see> array.</param>
            <returns>False if the static is not Immutable and is currently disabled, True otherwise.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If the provided <paramref name="staticColliderIndex"/> is not in the range of static colliders loaded in the current Physics static scene.</exception>
        </member>
        <member name="T:Quantum.Physics2D.JointType">
            <summary>
            Defines the type of a 2D <see cref="T:Quantum.Physics2D.Joint"/>.
            </summary>
            \ingroup PhysicsJoints2D
        </member>
        <member name="F:Quantum.Physics2D.JointType.None">
            <summary>
            Defines a Joint of no specific type, which are not solved by the Physics Engine.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.JointType.DistanceJoint">
            <summary>
            Defines the type of a <see cref="F:Quantum.Physics2D.JointType.DistanceJoint"/>.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.JointType.SpringJoint">
            <summary>
            Defines the type of a <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.JointType.HingeJoint">
            <summary>
            Defines the type of a <see cref="F:Quantum.Physics2D.JointType.HingeJoint"/>.
            </summary>
        </member>
        <member name="T:Quantum.Physics2D.Joint">
            <summary>
            Defines a connection between a 2D Physics Body and an anchor, according to velocity and/or position constraints.
            The connected anchor can be a world-space position or another entity with at least a transform component. 
            </summary>
            \ingroup PhysicsJoints2D
        </member>
        <member name="F:Quantum.Physics2D.Joint.UserTag">
            <summary>
            A numerical tag that can be used to identify a joint or a group of joints.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Joint.Anchor">
            <summary>
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Joint.ConnectedAnchor">
            <summary>
            If the joint has a <see cref="F:Quantum.Physics2D.Joint.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Joint.ConnectedEntity">
            <summary>
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics2D.Joint.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform2D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody2D"/>, joint forces are also computed and applied to it. 
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Joint.SpringJoint">
            <summary>
            Type-specific settings of a joint of type <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.
            <remarks>
            Different types of joints have their fields overlapping in memory.
            Thus, settings of a type different than this joint's <see cref="P:Quantum.Physics2D.Joint.Type"/> might have fields with unexpected values.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Joint.DistanceJoint">
            <summary>
            Type-specific settings of a joint of type <see cref="F:Quantum.Physics2D.JointType.DistanceJoint"/>.
            <remarks>
            Different types of joints have their fields overlapping in memory.
            Thus, settings of a type different than this joint's <see cref="P:Quantum.Physics2D.Joint.Type"/> might have fields with unexpected values.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Joint.HingeJoint">
            <summary>
            Type-specific settings of a joint of type <see cref="F:Quantum.Physics2D.JointType.HingeJoint"/>.
            <remarks>
            Different types of joints have their fields overlapping in memory.
            Thus, settings of a type different than this joint's <see cref="P:Quantum.Physics2D.Joint.Type"/> might have fields with unexpected values.
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Joint.Type">
            <summary>
            The type of this joint, indicating which type-specific settings should be accessed.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Joint.Enabled">
            <summary>
            If the constraints of this joint should be considered and resolved by the 2D Physics Engine. 
            </summary>
        </member>
        <member name="T:Quantum.Physics2D.DistanceJoint">
            <summary>
            A <see cref="T:Quantum.Physics2D.Joint"/> that connects a Physics Body to an anchor and attempts to keep them a certain distance apart.
            The connected anchor can be a world-space position or another entity with at least a transform component.
            </summary>
            \ingroup PhysicsJoints2D
        </member>
        <member name="F:Quantum.Physics2D.DistanceJoint.Anchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.Anchor"/>
            @copydoc Joint.Anchor
        </member>
        <member name="F:Quantum.Physics2D.DistanceJoint.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.ConnectedAnchor"/>
            @copydoc Joint.ConnectedAnchor
        </member>
        <member name="F:Quantum.Physics2D.DistanceJoint.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.ConnectedEntity"/>
            @copydoc Joint.ConnectedEntity
        </member>
        <member name="P:Quantum.Physics2D.DistanceJoint.MinDistance">
            <summary>
            The minimum distance between the anchor points that the joint will attempt to maintain.
            If set to zero or default, allows any distance below <see cref="P:Quantum.Physics2D.DistanceJoint.MaxDistance"/>.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.DistanceJoint.MaxDistance">
            <summary>
            The maximum distance between the anchor points that the joint will attempt to maintain.
            If set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>, allows any distance in the usable range above <see cref="P:Quantum.Physics2D.DistanceJoint.MinDistance"/>.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.DistanceJoint.#ctor(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Constructs a <see cref="T:Quantum.Physics2D.DistanceJoint"/> struct.
            Use <see cref="M:Quantum.Physics2D.DistanceJoint.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)"/> instead to create a 2D <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.DistanceJoint"/>.
            </summary>
            <inheritdoc cref="M:Quantum.Physics2D.DistanceJoint.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)"/>
            <returns></returns>
        </member>
        <member name="M:Quantum.Physics2D.DistanceJoint.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Creates a 2D <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.DistanceJoint"/>.
            </summary>
            <param name="minDistance">
            The minimum distance between the anchor points that the joint will attempt to maintain.
            If set to zero or default, allows any distance below <see cref="P:Quantum.Physics2D.DistanceJoint.MaxDistance"/>.
            </param>
            <param name="maxDistance">
            The maximum distance between the anchor points that the joint will attempt to maintain.
            If set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>, allows any distance in the usable range above <see cref="P:Quantum.Physics2D.DistanceJoint.MinDistance"/>.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics2D.DistanceJoint.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform2D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody2D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics2D.DistanceJoint.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.DistanceJoint"/>.</returns>
        </member>
        <member name="T:Quantum.Physics2D.HingeJoint">
            <summary>
            A <see cref="T:Quantum.Physics2D.Joint"/> that attaches a Physics Body to an anchor around which it can rotate.
            The connected anchor can be a world-space position or another entity with at least a transform component.
            The rotation can happen freely or, optionally, with limiting angles and/or a motor torque.
            </summary>
            \ingroup PhysicsJoints2D
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.Anchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.Anchor"/>
            @copydoc Joint.Anchor
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.ConnectedAnchor"/>
            @copydoc Joint.ConnectedAnchor
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.ConnectedEntity"/>
            @copydoc Joint.ConnectedEntity
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.LowerLimitRad">
            <summary>
            The lower angle of the allowed arc of rotation around the connected anchor, in radians.
            Set <see cref="P:Quantum.Physics2D.HingeJoint.UseAngleLimits"/> to enable or disable the angle-limiting constraints.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.UpperLimitRad">
            <summary>
            The upper angle of the allowed arc of rotation around the connected anchor, in radians.
            Set <see cref="P:Quantum.Physics2D.HingeJoint.UseAngleLimits"/> to enable or disable the angle-limiting constraints.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.MotorSpeed">
            <summary>
            The speed at which the hinge motor will attempt to rotate, in radians per second.
            Set <see cref="P:Quantum.Physics2D.HingeJoint.UseMotor"/> to enable or disable the hinge motor.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.MaxMotorTorque">
            <summary>
            The maximum torque produced by the hinge motor in order to achieve the target <see cref="F:Quantum.Physics2D.HingeJoint.MotorSpeed"/>.
            Set to <see cref="P:Photon.Deterministic.FP.UseableMax"/> in order to allow "unlimited" torque while respecting the FP usable range.
            Set <see cref="P:Quantum.Physics2D.HingeJoint.UseMotor"/> to enable or disable the hinge motor.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.HingeJoint.UseAngleLimits">
            <summary>
            If the <see cref="F:Quantum.Physics2D.HingeJoint.LowerLimitRad"/> and <see cref="F:Quantum.Physics2D.HingeJoint.UpperLimitRad"/> limiting constraints should be considered and resolved by the Physics Engine.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.HingeJoint.UseMotor">
            <summary>
            If the <see cref="F:Quantum.Physics2D.HingeJoint.MotorSpeed"/> and <see cref="F:Quantum.Physics2D.HingeJoint.MaxMotorTorque"/> constraints should be considered and resolved by the Physics Engine.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.HingeJoint.#ctor(Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Constructs a <see cref="T:Quantum.Physics2D.HingeJoint"/> struct.
            Use <see cref="M:Quantum.Physics2D.HingeJoint.CreateJoint(Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)"/> instead to create a 2D <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.HingeJoint"/>.
            </summary>
            <inheritdoc cref="M:Quantum.Physics2D.HingeJoint.CreateJoint(Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)"/>
            <returns></returns>
        </member>
        <member name="M:Quantum.Physics2D.HingeJoint.CreateJoint(Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Creates a 2D <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.HingeJoint"/>.
            </summary>
            <param name="lowerLimitRad">
            The lower angle of the allowed arc of rotation around the connected anchor, in radians.
            If none is provided, i.e. default(NullableFP), and an upper limiting angle is set, the lower angle will be set to <see cref="P:Photon.Deterministic.FP.UseableMin"/>.
            If both limiting angles are null, <see cref="P:Quantum.Physics2D.HingeJoint.UseAngleLimits"/> is false and related constraints will not be applied.
            </param>
            <param name="upperLimitRad">
            The upper angle of the allowed arc of rotation around the connected anchor, in radians.
            If none is provided, i.e. default(NullableFP), and an lower limiting angle is set, the upper angle will be set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>.
            If both limiting angles are null, <see cref="P:Quantum.Physics2D.HingeJoint.UseAngleLimits"/> is false and related constraints will not be applied.
            </param>
            <param name="motorSpeed">
            The speed at which the hinge motor will attempt to rotate, in radians per second.
            If none is provided, i.e. default(NullableFP), and a maximum motor toque is set, the target motor speed will be set to 0.
            If both motor speed and maximum torque are null, <see cref="P:Quantum.Physics2D.HingeJoint.UseMotor"/> is false and related constraints will not be applied.
            </param>
            <param name="maxMotorTorque">
            The maximum torque produced by the hinge motor in order to achieve the target <see cref="F:Quantum.Physics2D.HingeJoint.MotorSpeed"/>.
            If none is provided, i.e. default(NullableFP), and a target motor speed is set, the maximum torque will be set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>.
            If both motor speed and maximum torque are null, <see cref="P:Quantum.Physics2D.HingeJoint.UseMotor"/> is false and related constraints will not be applied.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics2D.HingeJoint.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform2D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody2D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics2D.HingeJoint.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.HingeJoint"/>.</returns>
        </member>
        <member name="T:Quantum.Physics2D.SpringJoint">
            <summary>
            A <see cref="T:Quantum.Physics2D.Joint"/> that attaches a Physics Body to an anchor as if connected by a spring, trying to keep them a certain distance apart.
            The connected anchor can be a world-space position or another entity with at least a transform component.
            </summary>
            \ingroup PhysicsJoints2D
        </member>
        <member name="F:Quantum.Physics2D.SpringJoint.Anchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.Anchor"/>
            @copydoc Joint.Anchor
        </member>
        <member name="F:Quantum.Physics2D.SpringJoint.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.ConnectedAnchor"/>
            @copydoc Joint.ConnectedAnchor
        </member>
        <member name="F:Quantum.Physics2D.SpringJoint.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.ConnectedEntity"/>
            @copydoc Joint.ConnectedEntity
        </member>
        <member name="F:Quantum.Physics2D.SpringJoint.Spring">
            <summary>
            The stiffness of the spring, in Newtons per meter (N/m).
            To get or set the frequency (Hz) at which the spring will attempt to oscillate, given the physics body(ies) involved, use <see cref="M:Quantum.Physics2D.SpringJoint.GetStiffness(Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/> and <see cref="M:Quantum.Physics2D.SpringJoint.SetStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*)"/>, respectively.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.SpringJoint.Damper">
            <summary>
            The damper capacity at which the spring oscillation is suppressed, in Newtons per square meter (N/m2).
            To get or set the damping RATIO, given the physics body(ies) involved, use <see cref="M:Quantum.Physics2D.SpringJoint.GetStiffness(Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/> and <see cref="M:Quantum.Physics2D.SpringJoint.SetStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*)"/>, respectively.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.SpringJoint.Distance">
            <summary>
            The distance between the anchor points that the joint will attempt to maintain.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.#ctor(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Constructs a <see cref="T:Quantum.Physics2D.SpringJoint"/> struct.
            Use CreateJoint overloads instead to create a <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.
            </summary>
            <inheritdoc cref="M:Quantum.Physics2D.SpringJoint.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)"/>
            <returns></returns>
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Creates a <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.
            </summary>
            <param name="spring">
            The stiffness of the spring, in Newtons per meter (N/m).
            </param>
            <param name="damper">
            The damping capacity at which the spring oscillation is suppressed, in Newtons per square meter (N/m2).
            </param>
            <param name="distance">
            The distance between the anchor points that the joint will attempt to maintain.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics2D.SpringJoint.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform2D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody2D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics2D.SpringJoint.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.</returns>
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D*,Quantum.EntityRef,Quantum.PhysicsBody2D*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Creates a 2D <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.
            </summary>
            <param name="frequency">
            The frequency in Hertz (Hz) at which the spring joint will attempt to oscillate, given the mass of the body(ies) involved.
            Typical values are below half the frequency of the simulation.
            </param>
            <param name="dampingRatio">
            A dimensionless value representing the damper capacity of suppressing the spring oscillation, typically between 0 and 1.
            </param>
            <param name="distance">
            The distance between the anchor points that the joint will attempt to maintain.
            </param>
            <param name="jointBody">
            The <see cref="T:Quantum.PhysicsBody2D"/> component of the joint entity.
            The body mass affects the spring rate necessary to achieve the target oscillation frequency.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics2D.SpringJoint.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform2D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody2D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="connectedBody">
            The <see cref="T:Quantum.PhysicsBody2D"/> component of the <paramref name="connectedEntity"/>, if it exists and has one.
            Can be null, in which case the spring/damper rates will be computed as if the joint is connected to a fixed point or kinematic body. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics2D.SpringJoint.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.</returns>
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.GetStiffness(Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)">
            <summary>
            Computes the <paramref name="frequency"/> and <paramref name="dampingRatio"/> based on the joint <see cref="F:Quantum.Physics2D.SpringJoint.Spring"/> and <see cref="F:Quantum.Physics2D.SpringJoint.Damper"/> capacities, given the physics body(ies) involved. 
            </summary>
            <param name="jointBody">
            The <see cref="T:Quantum.PhysicsBody2D"/> component of the joint entity.
            The body mass affects the resultant oscillation frequency, given the joint spring stiffness.
            </param>
            <param name="connectedBody">
            The <see cref="T:Quantum.PhysicsBody2D"/> component of the entity connected to the joint, if it exists and has one.
            Can be null, in which case the frequency and damping ratio will be computed as if the joint is connected to a fixed point or kinematic body. 
            </param>
            <param name="frequency">
            The frequency in Hertz (Hz) at which the spring joint will attempt to oscillate, given the mass of the body(ies) involved.
            Typical values are below half the frequency of the simulation.
            </param>
            <param name="dampingRatio">
            A dimensionless value representing the damper capacity of suppressing the spring oscillation, typically between 0 and 1.
            </param>
            <exception cref="T:System.NullReferenceException">If the <paramref name="jointBody"/> is null.</exception>
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.SetStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*)">
            <summary>
            Computes and sets the <see cref="F:Quantum.Physics2D.SpringJoint.Spring"/> and <see cref="F:Quantum.Physics2D.SpringJoint.Damper"/> capacities based on the target <paramref name="frequency"/> and <paramref name="dampingRatio"/>, given the physics body(ies) involved.
            </summary>
            <inheritdoc cref="M:Quantum.Physics2D.SpringJoint.GetStiffness(Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/>
            @copydetails GetStiffness
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.ComputeStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)">
            <summary>
            Computes the <paramref name="spring"/> and <paramref name="damper"/> capacities based on the target <paramref name="frequency"/> and <paramref name="dampingRatio"/>, given the physics body(ies) involved.
            </summary>
            <inheritdoc cref="M:Quantum.Physics2D.SpringJoint.GetStiffness(Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/>
            @copydetails GetStiffness
        </member>
        <member name="T:Quantum.Physics2D.Hit">
            <summary>
            Information returned from a valid hit of a physics query.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.Physics2D.Hit.ShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape2D.UserTag"/> field of the shape hit by the query.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Hit.OverlapPenetration">
            <summary>
            The penetration of a shape overlap query on the collider that was hit.
            <remarks>
            This field is not computed unless <see cref="F:Quantum.QueryOptions.ComputeDetailedInfo"/> is used in the query options
            and only applies to Shape Overlap queries.
            It overlaps in memory and is mutually exclusive with <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/>.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Hit.CastDistanceNormalized">
            <summary>
            A normalized value (0 to 1) of the feature being casted when the hit occurs, relative to its full cast distance.
            <remarks>
            This field only applies to Ray, Line or Shape casts.
            It overlaps in memory and is mutually exclusive with <see cref="F:Quantum.Physics2D.Hit.OverlapPenetration"/>.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Hit.Point">
            <summary>
            The point in world space where the collider is hit by the query.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Hit.Normal">
            <summary>
            The surface normal of the hit.
            <remarks>
            This field is not computed unless <see cref="F:Quantum.QueryOptions.ComputeDetailedInfo"/> is used in the query options.
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Hit.IsDynamic">
            <summary>
            If the collider hit by the query is not static, i.e. it belongs to an <see cref="P:Quantum.Physics2D.Hit.Entity"/>.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Hit.StaticColliderIndex">
            <summary>
            0-based index of the static collider on the <see cref="F:Quantum.Map.StaticColliders2D"/> array of the map referenced by <see cref="P:Quantum.Physics2D.Hit.StaticColliderMapRef"/>.
            If the hit <see cref="P:Quantum.Physics2D.Hit.IsDynamic"/>, this value is -1.
            Tip: use <see cref="M:Quantum.Physics2D.Hit.TryGetStaticCollider(Quantum.Core.FrameBase,Quantum.MapStaticCollider2D@)"/>, <see cref="M:Quantum.Physics2D.Hit.TryGetStaticData(Quantum.Core.FrameBase,Quantum.StaticColliderData@)"/>, <see cref="M:Quantum.Physics2D.Hit.GetStaticCollider(Quantum.Core.FrameBase)"/> or <see cref="M:Quantum.Physics2D.Hit.GetStaticData(Quantum.Core.FrameBase)"/>
            in order to safely and conveniently access info about a static collider hit.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Hit.StaticColliderMapRef">
            <summary>
            The reference to the map used by the physics engine when a static collider is hit.
            Otherwise, this value is default (hit <see cref="P:Quantum.Physics2D.Hit.IsDynamic"/>).
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Hit.IsTrigger">
            <summary>
            If the collider hit by the query is Trigger.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Hit.Entity">
            <summary>
            The reference of the entity hit by the query, <see cref="P:Quantum.EntityRef.None"/> if hitting a static collider (<see cref="P:Quantum.Physics2D.Hit.IsDynamic"/> false).
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.Hit.SetHitEntity(Quantum.EntityRef)">
            <summary>
            Sets the entity that was hit. Automatically resets <see cref="P:Quantum.Physics2D.Hit.StaticColliderIndex"/> to -1.
            </summary>
            <param name="entity">The entity reference.</param>
        </member>
        <member name="M:Quantum.Physics2D.Hit.SetHitStaticCollider(System.Int32,Quantum.AssetRefMap)">
            <summary>
            Sets the index of the static collider hit on the <see cref="F:Quantum.Map.StaticColliders2D"/> array of the referenced map.
            </summary>
            <param name="staticColliderIndex">A valid index of the static collider on the array of the map.</param>
            <param name="mapRef">A reference to the map where the static collider hit is located.</param>
        </member>
        <member name="M:Quantum.Physics2D.Hit.TryGetStaticCollider(Quantum.Core.FrameBase,Quantum.MapStaticCollider2D@)">
            <summary>
            Tries to access the static collider that was hit.
            </summary>
            <param name="f">Current frame.</param>
            <param name="collider">A copy of the static collider data found. Default if the metadata is not valid (returns false).</param>
            <returns>False if the collider hit is not static or the collide index or referenced map are not valid. True otherwise.</returns>
        </member>
        <member name="M:Quantum.Physics2D.Hit.TryGetStaticData(Quantum.Core.FrameBase,Quantum.StaticColliderData@)">
            <summary>
            Tries to access the data of the static collider that was hit (<see cref="F:Quantum.MapStaticCollider2D.StaticData"/>).
            </summary>
            <param name="f">Current frame.</param>
            <param name="data">A copy of the static collider data found. Default if the metadata is not valid (returns false).</param>
            <returns>False if the collider hit is not static or the collide index or referenced map are not valid. True otherwise.</returns>
        </member>
        <member name="M:Quantum.Physics2D.Hit.GetStaticCollider(Quantum.Core.FrameBase)">
            <summary>
            Gets a reference to the static collider hit. Does not perform additional safety checks.
            </summary>
            <param name="f">Current frame.</param>
            <exception cref="T:System.NullReferenceException">If the <see cref="P:Quantum.Physics2D.Hit.StaticColliderMapRef"/> does not reference a valid asset.</exception>
            <exception cref="T:System.IndexOutOfRangeException">If the hit is not static (<see cref="P:Quantum.Physics2D.Hit.IsDynamic"/>) or the collider index is not valid for the array of static colliders on the referenced map.</exception>
            <returns>A reference to the static collider hit.</returns>
        </member>
        <member name="M:Quantum.Physics2D.Hit.GetStaticData(Quantum.Core.FrameBase)">
            <summary>
            Gets a reference to the data of the static collider hit (<see cref="F:Quantum.MapStaticCollider2D.StaticData"/>). Does not perform additional safety checks.
            </summary>
            <param name="f">Current frame.</param>
            <exception cref="T:System.NullReferenceException">If the <see cref="P:Quantum.Physics2D.Hit.StaticColliderMapRef"/> does not reference a valid asset.</exception>
            <exception cref="T:System.IndexOutOfRangeException">If the hit is not static (<see cref="P:Quantum.Physics2D.Hit.IsDynamic"/>) or the collider index is not valid for the array of static colliders on the referenced map.</exception>
            <returns>A reference to the static collider hit.</returns>
        </member>
        <member name="M:Quantum.Physics2D.HitCollection.Sort(Photon.Deterministic.FPVector2)">
            <summary>
            Sort all hits in the collection, in ascending order, based on the distance from the <see cref="F:Quantum.Physics2D.Hit.Point"/> to the target <paramref name="point"/>.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.HitCollection.SortCastDistance">
            <summary>
            Sort all hits in the collection, in ascending order, based on the <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/>.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.Scene2D.Task_CreateEntriesMapping(Quantum.FrameThreadSafe,System.Int32,System.Int32,System.Void*)">
            <summary>
            Creates a mapping from EntityRef to Entry (usable for Joints, for instance).
            Must run after <see cref="M:Quantum.Physics2D.Scene2D.Task_CreateEntries(Quantum.FrameThreadSafe,System.Int32,System.Int32,System.Void*)"/> and in a single thread.
            </summary>
        </member>
        <member name="T:Quantum.PhysicsJoints2D">
            <summary>
            A component holding one or more <see cref="T:Quantum.Physics2D.Joint"/>,
            defining connections between a 2D Physics Body and anchors according to velocity and/or position constraints.
            </summary>
            \ingroup PhysicsJoints2D
        </member>
        <member name="P:Quantum.PhysicsJoints2D.Count">
            <summary>
            The current amount of joints tracked by the component.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsJoints2D.Capacity">
            <summary>
            The number of joints the currently allocated buffer can hold before having to be resized.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.AddJoint(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@)">
            <summary>
            Adds a <see cref="T:Quantum.Physics2D.Joint"/> to the component.
            If the buffer is at full <see cref="P:Quantum.PhysicsJoints2D.Capacity"/>, a new buffer will be allocated with double the capacity and existing entries are copied over.
            In that case, the previous buffer is not disposed immediately and cached pointers are still valid, although outdated.
            </summary>
            <param name="f">The current frame.</param>
            <param name="joint">The joint that will be added to the component.</param>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.RemoveJoints(Quantum.Core.FrameBase,System.Nullable{System.Int32})">
            <summary>
            Removes all joints in the component that have a <see cref="F:Quantum.Physics2D.Joint.UserTag"/> field matching the specified <paramref name="userTag"/>.
            If none is specified, all joints are removed.
            </summary>
            <remarks>
            This method does not keep the order of remaining elements in the buffer.
            To achieve that instead, use <see cref="M:Quantum.PhysicsJoints2D.GetJoints(Quantum.Core.FrameBase,System.Int32@)"/> and <see cref="M:Quantum.PhysicsJoints2D.RemoveAt(Quantum.Core.FrameBase,System.Int32)"/> while iterating the buffer in reverse order.
            </remarks>
            <param name="f">The current frame.</param>
            <param name="userTag">
            A numerical tag that can be used to identify a joint or a group of joints.
            Any joint in the component that matches the tag will be removed.
            If none is specified, all joints are removed.
            </param>
            <returns>True if at least one joint has been removed.</returns>
            <code>
            const int removeJointsUserTag = 42;
            
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            if (removeAll) {
              jointsComponent->RemoveJoints(f);
            } else {
              jointsComponent->RemoveJoints(f, removeJointsUserTag);
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.RemoveAt(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Removes the joint at the specified <paramref name="index"/> of the component's joints buffer, while keeping the order of the remaining objects.
            If the remaining elements do not need to be kept in order, <see cref="M:Quantum.PhysicsJoints2D.RemoveAtUnordered(Quantum.Core.FrameBase,System.Int32)"/> is a cheaper option.
            </summary>
            <param name="f">The current frame.</param>
            <param name="index">The index of the element to be removed.</param>
            <exception cref="T:System.NullReferenceException">If the joints buffer is not allocated.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the <paramref name="index"/> is outside the valid range.</exception>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            
            if (jointsComponent->TryGetJoints(f, out var joints, out var count)) {
              // by iterating the buffer in reverse order we avoid skipping elements if also removing
              for (var i = count - 1; i >= 0; i--) {
                var current = joints + i;
            
                if (current->Type == Physics2D.JointType.DistanceJoint) {
                  // removes the element at the current index, keeping the order of the remaining ones
                  jointsComponent->RemoveAt(f, i);
                }
              }
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.RemoveAtUnordered(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Removes the joint at the specified <paramref name="index"/> of the component's joints buffer.
            The order of the elements with indices greater than <paramref name="index"/> is not kept.
            If the order must be kept, use <see cref="M:Quantum.PhysicsJoints2D.RemoveAt(Quantum.Core.FrameBase,System.Int32)"/> instead.
            </summary>
            <param name="f">The current frame.</param>
            <param name="index">The index of the element to be removed.</param>
            <exception cref="T:System.NullReferenceException">If the joints buffer is not allocated.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the <paramref name="index"/> is outside the valid range.</exception>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            
            if (jointsComponent->TryGetJoints(f, out var joints, out var count)) {
              // by iterating the buffer in reverse order we avoid skipping elements if also removing
              for (var i = count - 1; i >= 0; i--) {
                var current = joints + i;
            
                if (current->Type == Physics2D.JointType.DistanceJoint) {
                  // removes the element at the current index
                  // the order of the elements with index greater than i is not ensured
                  jointsComponent->RemoveAtUnordered(f, i);
                }
              }
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.TryGetJoints(Quantum.Core.FrameBase,Quantum.Physics2D.Joint*@,System.Int32@)">
            <summary>
            Gets the currently allocated buffer for the component joints, if it has one.
            See also <see cref="M:Quantum.PhysicsJoints2D.GetIterator(Quantum.Core.FrameBase,System.Boolean)"/> to iterate over the buffer with an auxiliary structure.
            </summary>
            <param name="f">The current frame.</param>
            <param name="joints">The allocated buffer for the component joints. Null if the buffer is not allocated.</param>
            <param name="count">The number of elements used in the buffer at the moment this method is called. 0 if the buffer is not allocated.</param>
            <returns>True if the buffer is allocated.</returns>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            
            if (jointsComponent->TryGetJoints(f, out var joints, out var count)) {
              for (var i = 0; i &lt; count; i++) {
                var current = joints + i;
                Log.Info($"Joint Type {i}: {current->Type}");
              }
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.GetJoints(Quantum.Core.FrameBase,System.Int32@)">
            <summary>
            Gets the currently allocated buffer for the component joints.
            See also <see cref="M:Quantum.PhysicsJoints2D.GetIterator(Quantum.Core.FrameBase,System.Boolean)"/> to iterate over the buffer with an auxiliary structure.
            </summary>
            <param name="f">The current frame.</param>
            <param name="count">The number of elements used in the buffer at the moment this method is called.</param>
            <returns>The allocated buffer for the component joints.</returns>
            <exception cref="T:System.NullReferenceException">If the buffer is not allocated.</exception>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            var joints = jointsComponent->GetJoints(f, out var count);
            
            for (var i = 0; i &lt; count; i++) {
              var current = joints + i;
              Log.Info($"Joint Type {i}: {current->Type}");
            }
            </code>
        </member>
        <member name="T:Quantum.PhysicsJoints2D.JointsIterator">
            <summary>
            An auxiliary struct to iterate over the joints on a <see cref="T:Quantum.PhysicsJoints2D"/> component.
            Use <see cref="M:Quantum.PhysicsJoints2D.GetIterator(Quantum.Core.FrameBase,System.Boolean)"/> to acquire an iterator for the component's joint buffer.
            </summary>
            <remarks>
            If new elements are added while iterating and this causes the buffer to be expanded,
            the iterator will keep iterating over the previous buffer, which is not immediately disposed (see <see cref="M:Quantum.PhysicsJoints2D.AddJoint(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@)"/>).
            In this case, further changes to elements in the buffer being iterated will not modify the elements on the new buffer.
            Hence, the addition of elements while iterating is not recommended, unless the access to the elements are read-only.
            </remarks>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            var jointsIterator  = jointsComponent->GetIterator(f);
            
            while (jointsIterator.MoveNext()) {
              // CurrentUnsafe is a pointer to the element in the buffer
              jointsIterator.CurrentUnsafe->Enabled = true;
            
              // Current is a copy of the joint being currently iterated
              var jointCopy = jointsIterator.Current;
              Assert.Check(jointCopy.Enabled);
            
              // by default, the iterator will go through the elements in reverse order.
              // this allows the removal of elements while iterating without this causing elements to be skipped as a byproduct.
              if (jointCopy.Type == Physics2D.JointType.None) {
                jointsComponent->RemoveAtUnordered(f, jointsIterator.CurrentIndex);
              }
            }
            </code>
            \ingroup PhysicsJoints2D
        </member>
        <member name="M:Quantum.PhysicsJoints2D.JointsIterator.GetEnumerator">
            <summary>
            The iterator is also an enumerator.
            This method is useful for accessing the elements in a foreach loop, for instance.
            </summary>
            <returns>A copy of this iterator on its current state.</returns>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.JointsIterator.MoveNext">
            <summary>
            Moves to the next joint.
            </summary>
            <returns>True if there is a next element.</returns>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.JointsIterator.Reset">
            <summary>
            Resets the iterator to its original state.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsJoints2D.JointsIterator.CurrentUnsafe">
            <summary>
            A pointer to the current joint being iterated.
            This allows modifications to the element in the actual buffer of joints.
            </summary>
            <exception cref="T:System.NullReferenceException">If the iterator buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the iterator current index is outside the valid range of the buffer: [0, count).</exception>
        </member>
        <member name="P:Quantum.PhysicsJoints2D.JointsIterator.Current">
            <summary>
            A copy of the current joint being iterated.
            To modify the actual element in the buffer, use <see cref="P:Quantum.PhysicsJoints2D.JointsIterator.CurrentUnsafe"/> instead.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsJoints2D.JointsIterator.CurrentIndex">
            <summary>
            The index on the buffer of the element currently being iterated.
            The index is out of the valid range if the iterator has just been created on <see cref="M:Quantum.PhysicsJoints2D.JointsIterator.Reset"/>.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.GetIterator(Quantum.Core.FrameBase,System.Boolean)">
            <summary>
            Gets an auxiliary struct to iterate over the joints in this component.
            See also <see cref="M:Quantum.PhysicsJoints2D.TryGetJoints(Quantum.Core.FrameBase,Quantum.Physics2D.Joint*@,System.Int32@)"/> and <see cref="M:Quantum.PhysicsJoints2D.GetJoints(Quantum.Core.FrameBase,System.Int32@)"/> to have direct access to the buffer.
            </summary>
            <remarks>
            If new elements are added while iterating and this causes the buffer to be expanded,
            the iterator will keep iterating over the previous buffer, which is not immediately disposed (see <see cref="M:Quantum.PhysicsJoints2D.AddJoint(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@)"/>).
            In this case, further changes to elements in the buffer being iterated will not modify the elements on the new buffer.
            Hence, the addition of elements while iterating is not recommended, unless the access to the elements are read-only.
            </remarks>
            <param name="f">The current frame.</param>
            <param name="reverseOrder">
            If the buffer elements should be iterated in reverse order.
            If true, allows the removal of elements while iterating without it causing some elements to be skipped.
            </param>
            <returns>A <see cref="T:Quantum.PhysicsJoints2D.JointsIterator"/> for the buffer of joints in this component.</returns>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            var jointsIterator  = jointsComponent->GetIterator(f);
            
            while (jointsIterator.MoveNext()) {
              // CurrentUnsafe is a pointer to the element in the buffer
              jointsIterator.CurrentUnsafe->Enabled = true;
            
              // Current is a copy of the joint being currently iterated
              var jointCopy = jointsIterator.Current;
              Assert.Check(jointCopy.Enabled);
            
              // by default, the iterator will go through the elements in reverse order.
              // this allows the removal of elements while iterating without this causing elements to be skipped as a byproduct.
              if (jointCopy.Type == Physics2D.JointType.None) {
                jointsComponent->RemoveAtUnordered(f, jointsIterator.CurrentIndex);
              }
            }
            </code>
        </member>
        <member name="T:Quantum.Physics3D.PhysicsEngine3D">
            <summary>
            3D Physics API
            </summary>
        </member>
        <member name="T:Quantum.Physics3D.PhysicsEngine3D.Api">
            <summary>
            3D Physics API
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)">
            <summary>
            Sets which 3D physics collision callbacks will be called for the <paramref name="entity"/>.
            <remarks>The entity must have a PhysicsCollider3D component attached to be able to collide with other physics entries.</remarks>
            <remarks>For receiving the callbacks, set the <see cref="T:Quantum.CallbackFlags"/> and implement the corresponding signal on a system.</remarks>
            </summary>
            <param name="entity">An entity with a PhysicsCollider3D component attached.</param>
            <param name="flags">The <see cref="T:Quantum.CallbackFlags"/> of the desired collision callbacks.</param>
            <code>frame.Physics3D.SetCallbacks(entity, CallbackFlags.OnDynamicCollision | CallbackFlags.OnStaticTriggerEnter);</code>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetCallbacks(Quantum.EntityRef)">
            <summary>
            Get the flags that represent which 3D physics collision callbacks will be called for the <paramref name="entity"/>.
            <remarks>The entity must have a PhysicsCollider3D component attached to be able to collide with other physics entries.</remarks>
            <remarks>To modify the callbacks, use <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            </summary>
            <param name="entity">The entity from which to get the callback flags.</param>
            <returns>The callback flags set to a given entity. Default if the entity did not have callback flags set.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ResetCallbacks(Quantum.EntityRef)">
            <summary>
            Resets the tracking history of collisions the <paramref name="entity"/> might have.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ResetMap">
            <summary>
            Resets 3D physics scene map asset guid.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="P:Quantum.Physics3D.PhysicsEngine3D.Api.Map">
            <summary>
            Retrieves the map asset currently used on the physics scene.
            <remarks>
            The map currently used by the physics scene is only updated during verified simulations,
            so this map can be different from the frame Map during predictions, when the latter is changed. 
            </remarks>
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.Print(Quantum.FramePrinter)">
            <summary>
            Prints the 3D Physics Engine state on the provided frame <paramref name="printer"/>.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)">
            <summary>
            Allocates a persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/> on the heap with an initial capacity.
            To free an allocated persistent collection of 3D hits, use <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.FreePersistentHitCollection3D(Quantum.Physics3D.HitCollection3D*)"/>.
            </summary>
            <param name="defaultCapacity">The initial <see cref="T:Quantum.Physics3D.Hit3D"/> buffer capacity allocated for the hit collection.</param>
            <returns>A pointer to the allocated hit collection.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.FreePersistentHitCollection3D(Quantum.Physics3D.HitCollection3D*)">
            <summary>
            Free a persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/> previously allocated on the heap.
            To allocate a persistent collection of 3D hits, use <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.
            </summary>
            <param name="collection">A pointer to the persistent hit collection to be freed.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the hit collection was not allocated as persistent.</exception>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetQueryHits(System.Int32)">
            <summary>
            Gets the results of a broad-phase query added to the 3D physics scene.
            </summary>
            <param name="index">The broad-phase query index.</param>
            <returns>A <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.TryGetQueryHits(System.Int32,Quantum.Physics3D.HitCollection3D@)">
            <summary>
            Tries to get the results of a broad-phase query added to the 3D physics scene.
            </summary>
            <param name="index">The broad-phase query index.</param>
            <param name="queryHits">The <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits. Default if the index is not valid.</param>
            <returns>True if the index is valid, false otherwise.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetAllQueriesHits(Quantum.Physics3D.HitCollection3D*@,System.Int32@)">
            <summary>
            Gets all the results for all the broad-phase queries added to the 3D physics scene this frame.
            </summary>
            <param name="queriesHits">A buffer of <see cref="T:Quantum.Physics3D.HitCollection3D"/> with <paramref name="queriesCount"/> elements, one for each broad-phase query added.</param>
            <param name="queriesCount">The number of elements in the <paramref name="queriesHits"/> buffer, also matching the number on broad-phase queries added.</param>
            <returns>True if at least one broad-phase query has been added from a system that runs before the physics engine.</returns>
            <example>
            Example of how to iterate over added broad-phase queries results.
            <code>
            if (f.Physics3D.GetAllQueriesHits(out var queriesHits, out var queriesCount)) {
              for (var i = 0; i &lt; queriesCount; i++) {
                var queryHits = queriesHits + i;
                Log.Info($"Preemptive query {i} has {queryHits->Count} hits.");
              }
            }
            </code>
            </example>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.AddRaycastQuery(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Boolean,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase ray cast query to the 3D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="origin">The ray origin point, in a 3D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="firstHitOnly">If the query results should return only the closest hit to the ray <paramref name="origin"/> or all hits (default).</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetQueryHits(System.Int32)"/>.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.AddLinecastQuery(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Boolean,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase line cast query to the 3D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="start">The line start point, in a 3D world space.</param>
            <param name="end">The line end point, in a 3D world space.</param>
            <param name="firstHitOnly">If the query results should return only the closest hit to the line <paramref name="start"/> or all hits (default).</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetQueryHits(System.Int32)"/>.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.Raycast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a ray cast and returns the closest hit to the ray origin, if any.
            </summary>
            <param name="origin">The ray origin point, in a 3D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A nullable <see cref="T:Quantum.Physics3D.Hit3D"/> with the closest hit to the ray origin, if any.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.Raycast(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a ray cast and adds the closest hit to the ray origin, if any, to a persistent collection of hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="origin">The ray origin point, in a 3D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.Linecast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a line cast and returns the closest hit to the line start, if any.
            </summary>
            <param name="start">The line start point, in a 3D world space.</param>
            <param name="end">The line end point, in a 3D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A nullable <see cref="T:Quantum.Physics3D.Hit3D"/> with the closest hit to the line start, if any.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.Linecast(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a line cast and adds the closest hit to the line start, if any, to a persistent collection of hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="start">The line start point, in a 3D world space.</param>
            <param name="end">The line end point, in a 3D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.RaycastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a ray cast, returning all hits.
            </summary>
            <param name="origin">The ray origin point, in a 3D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.RaycastAll(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a ray cast, adding all hits to a persistent collection.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="origin">The ray origin point, in a 3D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.LinecastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a line cast, returning all hits.
            </summary>
            <param name="start">The line start point, in a 3D world space.</param>
            <param name="end">The line end point, in a 3D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.LinecastAll(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a line cast, returning all hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="start">The line start point, in a 3D world space.</param>
            <param name="end">The line end point, in a 3D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.AddShapeCastQuery(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Boolean,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase shape cast query to the 3D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="start">The cast start point, in a 3D world space.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="firstHitOnly">If the query results should return only the hit with the smallest <see cref="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized"/> or all hits (default).</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetQueryHits(System.Int32)"/>.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape cast and returns the hit with the smallest <see cref="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized"/>, if any.
            </summary>
            <param name="start">The cast start, in a 3D world space.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A nullable <see cref="T:Quantum.Physics3D.Hit3D"/> with the smallest <see cref="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized"/>, if any.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCast(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape cast and adds the hit with the shortest <see cref="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized"/>, if any, to a persistent collection of hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="start">The cast start, in a 3D world space.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape cast, returning all hits.
            </summary>
            <param name="start">The cast start, in a 3D world space.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCastAll(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape cast, adding all hits to a persistent collection.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="start">The cast start, in a 3D world space.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.AddOverlapShapeQuery(Quantum.Transform3D,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase shape overlap query to the 3D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="transform">A 3D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetQueryHits(System.Int32)"/>.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.AddOverlapShapeQuery(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase shape overlap query to the 3D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="position">The position in which the shape is overlapped.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetQueryHits(System.Int32)"/>.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.OverlapShape(Quantum.Physics3D.HitCollection3D*,Quantum.Transform3D,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape overlap.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="transform">A 3D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the hit collection is not persistent.</exception>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.OverlapShape(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape overlap.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="position">The position in which the shape is overlapped.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the hit collection is not persistent.</exception>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.OverlapShape(Quantum.Transform3D,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape overlap.
            </summary>
            <param name="transform">A 3D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.OverlapShape(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape overlap.
            </summary>
            <param name="position">The 3D position in which the shape is overlapped.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.SetStaticColliderEnabled(System.Int32,System.Boolean)">
            <summary>
            Set a toggleable 3D static collider enabled state to <paramref name="enabled"/>.
            Disabled static colliders are not considered for collisions or on query resolutions.
            <remarks>The static collider state is only changed on Verified frames.</remarks>
            </summary>
            <param name="staticColliderIndex">The index of the collider in the Map <see cref="F:Quantum.Map.StaticColliders3D">StaticColliders3D</see> array.</param>
            <param name="enabled">If the static should be enabled (true) or disabled (false).</param>
            <exception cref="T:System.InvalidOperationException">If the static collider is baked as Immutable.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the provided <paramref name="staticColliderIndex"/> is not in the range of static colliders loaded in the current Physics static scene.</exception>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.IsStaticColliderEnabled(System.Int32)">
            <summary>
            Returns the current state of a 3D static collider.
            </summary>
            <param name="staticColliderIndex">The index of the collider in the Map <see cref="F:Quantum.Map.StaticColliders3D">StaticColliders3D</see> array.</param>
            <returns>False if the static is not Immutable and is currently disabled, True otherwise.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If the provided <paramref name="staticColliderIndex"/> is not in the range of static colliders loaded in the current Physics static scene.</exception>
        </member>
        <member name="T:Quantum.Physics3D.DistanceJoint3D">
            <summary>
            A <see cref="T:Quantum.Physics3D.Joint3D"/> that connects a Physics Body to an anchor and attempts to keep them a certain distance apart.
            The connected anchor can be a world-space position or another entity with at least a transform component.
            </summary>
            \ingroup PhysicsJoints3D
        </member>
        <member name="F:Quantum.Physics3D.DistanceJoint3D.Anchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.Anchor"/>
            @copydoc Joint3D.Anchor
        </member>
        <member name="F:Quantum.Physics3D.DistanceJoint3D.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.ConnectedAnchor"/>
            @copydoc Joint3D.ConnectedAnchor
        </member>
        <member name="F:Quantum.Physics3D.DistanceJoint3D.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.ConnectedEntity"/>
            @copydoc Joint3D.ConnectedEntity
        </member>
        <member name="P:Quantum.Physics3D.DistanceJoint3D.MinDistance">
            <summary>
            The minimum distance between the anchor points that the joint will attempt to maintain.
            If set to zero or default, allows any distance below <see cref="P:Quantum.Physics3D.DistanceJoint3D.MaxDistance"/>.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.DistanceJoint3D.MaxDistance">
            <summary>
            The maximum distance between the anchor points that the joint will attempt to maintain.
            If set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>, allows any distance in the usable range above <see cref="P:Quantum.Physics3D.DistanceJoint3D.MinDistance"/>.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.DistanceJoint3D.#ctor(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Constructs a <see cref="T:Quantum.Physics3D.DistanceJoint3D"/> struct.
            Use <see cref="M:Quantum.Physics3D.DistanceJoint3D.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)"/> instead to create a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.DistanceJoint"/>.
            </summary>
            <inheritdoc cref="M:Quantum.Physics3D.DistanceJoint3D.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)"/>
            <returns></returns>
        </member>
        <member name="M:Quantum.Physics3D.DistanceJoint3D.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Creates a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.DistanceJoint"/>.
            </summary>
            <param name="minDistance">
            The minimum distance between the anchor points that the joint will attempt to maintain.
            If set to zero or default, allows any distance below <see cref="P:Quantum.Physics3D.DistanceJoint3D.MaxDistance"/>.
            </param>
            <param name="maxDistance">
            The maximum distance between the anchor points that the joint will attempt to maintain.
            If set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>, allows any distance in the usable range above <see cref="P:Quantum.Physics3D.DistanceJoint3D.MinDistance"/>.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics3D.DistanceJoint3D.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform3D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody3D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics3D.DistanceJoint3D.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.DistanceJoint"/>.</returns>
        </member>
        <member name="T:Quantum.Physics3D.HingeJoint3D">
            <summary>
            A <see cref="T:Quantum.Physics3D.Joint3D"/> that attaches a Physics Body to an anchor around which it can rotate.
            The connected anchor can be a world-space position or another entity with at least a transform component.
            The rotation can happen freely or, optionally, with limiting angles and/or a motor torque.
            </summary>
            \ingroup PhysicsJoints3D
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.Anchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.Anchor"/>
            @copydoc Joint3D.Anchor
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.ConnectedAnchor"/>
            @copydoc Joint3D.ConnectedAnchor
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.ConnectedEntity"/>
            @copydoc Joint3D.ConnectedEntity
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.LowerLimitRad">
            <summary>
            The lower angle of the allowed arc of rotation around the connected anchor, in radians.
            Set <see cref="P:Quantum.Physics3D.HingeJoint3D.UseAngleLimits"/> to enable or disable the angle-limiting constraints.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.UpperLimitRad">
            <summary>
            The upper angle of the allowed arc of rotation around the connected anchor, in radians.
            Set <see cref="P:Quantum.Physics3D.HingeJoint3D.UseAngleLimits"/> to enable or disable the angle-limiting constraints.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.MotorSpeed">
            <summary>
            The speed at which the hinge motor will attempt to rotate, in radians per second.
            Set <see cref="P:Quantum.Physics3D.HingeJoint3D.UseMotor"/> to enable or disable the hinge motor.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.MaxMotorTorque">
            <summary>
            The maximum torque produced by the hinge motor in order to achieve the target <see cref="F:Quantum.Physics3D.HingeJoint3D.MotorSpeed"/>.
            Set to <see cref="P:Photon.Deterministic.FP.UseableMax"/> in order to allow "unlimited" torque while respecting the FP usable range.
            Set <see cref="P:Quantum.Physics3D.HingeJoint3D.UseMotor"/> to enable or disable the hinge motor.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.HingeJoint3D.UseAngleLimits">
            <summary>
            If the <see cref="F:Quantum.Physics3D.HingeJoint3D.LowerLimitRad"/> and <see cref="F:Quantum.Physics3D.HingeJoint3D.UpperLimitRad"/> limiting constraints should be considered and resolved by the Physics Engine.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.HingeJoint3D.UseMotor">
            <summary>
            If the <see cref="F:Quantum.Physics3D.HingeJoint3D.MotorSpeed"/> and <see cref="F:Quantum.Physics3D.HingeJoint3D.MaxMotorTorque"/> constraints should be considered and resolved by the Physics Engine.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.HingeJoint3D.Axis">
            <summary>
            Axis around which the joint rotates, defined in the local space of the entity.
            To modify the axis, use <see cref="M:Quantum.Physics3D.HingeJoint3D.SetAxis(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.HingeJoint3D.#ctor(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Constructs a <see cref="T:Quantum.Physics3D.HingeJoint3D"/> struct.
            Use <see cref="M:Quantum.Physics3D.HingeJoint3D.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)"/> instead to create a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.HingeJoint"/>.
            </summary>
            <inheritdoc cref="M:Quantum.Physics3D.HingeJoint3D.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)"/>
            <returns></returns>
        </member>
        <member name="M:Quantum.Physics3D.HingeJoint3D.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Creates a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.HingeJoint"/>.
            </summary>
            <param name="f"></param>
            <param name="jointEntity"></param>
            <param name="axis">
            Axis around which the joint rotates, defined in the local space of the entity.
            The vector is normalized before set. If zeroed, <see cref="P:Photon.Deterministic.FPVector3.Right"/> is used instead.
            </param>
            <param name="lowerLimitRad">
            The lower angle of the allowed arc of rotation around the connected anchor, in radians.
            If none is provided, i.e. default(NullableFP), and an upper limiting angle is set, the lower angle will be set to <see cref="P:Photon.Deterministic.FP.UseableMin"/>.
            If both limiting angles are null, <see cref="P:Quantum.Physics3D.HingeJoint3D.UseAngleLimits"/> is false and related constraints will not be applied.
            </param>
            <param name="upperLimitRad">
            The upper angle of the allowed arc of rotation around the connected anchor, in radians.
            If none is provided, i.e. default(NullableFP), and an lower limiting angle is set, the upper angle will be set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>.
            If both limiting angles are null, <see cref="P:Quantum.Physics3D.HingeJoint3D.UseAngleLimits"/> is false and related constraints will not be applied.
            </param>
            <param name="motorSpeed">
            The speed at which the hinge motor will attempt to rotate, in radians per second.
            If none is provided, i.e. default(NullableFP), and a maximum motor toque is set, the target motor speed will be set to 0.
            If both motor speed and maximum torque are null, <see cref="P:Quantum.Physics3D.HingeJoint3D.UseMotor"/> is false and related constraints will not be applied.
            </param>
            <param name="maxMotorTorque">
            The maximum torque produced by the hinge motor in order to achieve the target <see cref="F:Quantum.Physics3D.HingeJoint3D.MotorSpeed"/>.
            If none is provided, i.e. default(NullableFP), and a target motor speed is set, the maximum torque will be set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>.
            If both motor speed and maximum torque are null, <see cref="P:Quantum.Physics3D.HingeJoint3D.UseMotor"/> is false and related constraints will not be applied.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics3D.HingeJoint3D.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform3D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody3D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics3D.HingeJoint3D.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.HingeJoint"/>.</returns>
        </member>
        <member name="T:Quantum.Physics3D.SpringJoint3D">
            <summary>
            A <see cref="T:Quantum.Physics3D.Joint3D"/> that attaches a Physics Body to an anchor as if connected by a spring, trying to keep them a certain distance apart.
            The connected anchor can be a world-space position or another entity with at least a transform component.
            </summary>
            \ingroup PhysicsJoints3D
        </member>
        <member name="F:Quantum.Physics3D.SpringJoint3D.Anchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.Anchor"/>
            @copydoc Joint3D.Anchor
        </member>
        <member name="F:Quantum.Physics3D.SpringJoint3D.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.ConnectedAnchor"/>
            @copydoc Joint3D.ConnectedAnchor
        </member>
        <member name="F:Quantum.Physics3D.SpringJoint3D.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.ConnectedEntity"/>
            @copydoc Joint3D.ConnectedEntity
        </member>
        <member name="F:Quantum.Physics3D.SpringJoint3D.Spring">
            <summary>
            The stiffness of the spring, in Newtons per meter (N/m).
            To get or set the frequency (Hz) at which the spring will attempt to oscillate, given the physics body(ies) involved, use <see cref="M:Quantum.Physics3D.SpringJoint3D.GetStiffness(Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/> and <see cref="M:Quantum.Physics3D.SpringJoint3D.SetStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*)"/>, respectively.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.SpringJoint3D.Damper">
            <summary>
            The damper capacity at which the spring oscillation is suppressed, in Newtons per square meter (N/m2).
            To get or set the damping RATIO, given the physics body(ies) involved, use <see cref="M:Quantum.Physics3D.SpringJoint3D.GetStiffness(Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/> and <see cref="M:Quantum.Physics3D.SpringJoint3D.SetStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*)"/>, respectively.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.SpringJoint3D.Distance">
            <summary>
            The distance between the anchor points that the joint will attempt to maintain.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.#ctor(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Constructs a <see cref="T:Quantum.Physics3D.SpringJoint3D"/> struct.
            Use CreateJoint overloads instead to create a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.SpringJoint"/>.
            </summary>
            <inheritdoc cref="M:Quantum.Physics3D.SpringJoint3D.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)"/>
            <returns></returns>
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Creates a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.SpringJoint"/>.
            </summary>
            <param name="spring">
            The stiffness of the spring, in Newtons per meter (N/m).
            </param>
            <param name="damper">
            The damping capacity at which the spring oscillation is suppressed, in Newtons per square meter (N/m2).
            </param>
            <param name="distance">
            The distance between the anchor points that the joint will attempt to maintain.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics3D.SpringJoint3D.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform3D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody3D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics3D.SpringJoint3D.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.SpringJoint"/>.</returns>
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D*,Quantum.EntityRef,Quantum.PhysicsBody3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Creates a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.SpringJoint"/>.
            </summary>
            <param name="frequency">
            The frequency in Hertz (Hz) at which the spring joint will attempt to oscillate, given the mass of the body(ies) involved.
            Typical values are below half the frequency of the simulation.
            </param>
            <param name="dampingRatio">
            A dimensionless value representing the damper capacity of suppressing the spring oscillation, typically between 0 and 1.
            </param>
            <param name="distance">
            The distance between the anchor points that the joint will attempt to maintain.
            </param>
            <param name="jointBody">
            The <see cref="T:Quantum.PhysicsBody3D"/> component of the joint entity.
            The body mass affects the spring rate necessary to achieve the target oscillation frequency.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics3D.SpringJoint3D.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform3D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody3D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="connectedBody">
            The <see cref="T:Quantum.PhysicsBody3D"/> component of the <paramref name="connectedEntity"/>, if it exists and has one.
            Can be null, in which case the spring/damper rates will be computed as if the joint is connected to a fixed point or kinematic body. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics3D.SpringJoint3D.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.SpringJoint"/>.</returns>
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.GetStiffness(Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)">
            <summary>
            Computes the <paramref name="frequency"/> and <paramref name="dampingRatio"/> based on the joint <see cref="F:Quantum.Physics3D.SpringJoint3D.Spring"/> and <see cref="F:Quantum.Physics3D.SpringJoint3D.Damper"/> capacities, given the physics body(ies) involved. 
            </summary>
            <param name="jointBody">
            The <see cref="T:Quantum.PhysicsBody3D"/> component of the joint entity.
            The body mass affects the resultant oscillation frequency, given the joint spring stiffness.
            </param>
            <param name="connectedBody">
            The <see cref="T:Quantum.PhysicsBody3D"/> component of the entity connected to the joint, if it exists and has one.
            Can be null, in which case the frequency and damping ratio will be computed as if the joint is connected to a fixed point or kinematic body. 
            </param>
            <param name="frequency">
            The frequency in Hertz (Hz) at which the spring joint will attempt to oscillate, given the mass of the body(ies) involved.
            Typical values are below half the frequency of the simulation.
            </param>
            <param name="dampingRatio">
            A dimensionless value representing the damper capacity of suppressing the spring oscillation, typically between 0 and 1.
            </param>
            <exception cref="T:System.NullReferenceException">If the <paramref name="jointBody"/> is null.</exception>
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.SetStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*)">
            <summary>
            Computes and sets the <see cref="F:Quantum.Physics3D.SpringJoint3D.Spring"/> and <see cref="F:Quantum.Physics3D.SpringJoint3D.Damper"/> capacities based on the target <paramref name="frequency"/> and <paramref name="dampingRatio"/>, given the physics body(ies) involved.
            </summary>
            <inheritdoc cref="M:Quantum.Physics3D.SpringJoint3D.GetStiffness(Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/>
            @copydetails GetStiffness
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.ComputeStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)">
            <summary>
            Computes the <paramref name="spring"/> and <paramref name="damper"/> capacities based on the target <paramref name="frequency"/> and <paramref name="dampingRatio"/>, given the physics body(ies) involved.
            </summary>
            <inheritdoc cref="M:Quantum.Physics3D.SpringJoint3D.GetStiffness(Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/>
            @copydetails GetStiffness
        </member>
        <member name="T:Quantum.Physics3D.JointType3D">
            <summary>
            Defines the type of a 3D <see cref="T:Quantum.Physics3D.Joint3D"/>.
            </summary>
            \ingroup PhysicsJoints3D
        </member>
        <member name="F:Quantum.Physics3D.JointType3D.None">
            <summary>
            Defines a Joint of no specific type, which are not solved by the Physics Engine.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.JointType3D.DistanceJoint">
            <summary>
            Defines the type of a <see cref="T:Quantum.Physics3D.DistanceJoint3D"/>.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.JointType3D.SpringJoint">
            <summary>
            Defines the type of a <see cref="T:Quantum.Physics3D.SpringJoint3D"/>.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.JointType3D.HingeJoint">
            <summary>
            Defines the type of a <see cref="T:Quantum.Physics3D.HingeJoint3D"/>.
            </summary>
        </member>
        <member name="T:Quantum.Physics3D.Joint3D">
            <summary>
            Defines a connection between a 3D Physics Body and an anchor, according to velocity and/or position constraints.
            The connected anchor can be a world-space position or another entity with at least a transform component. 
            </summary>
            \ingroup PhysicsJoints3D
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.UserTag">
            <summary>
            A numerical tag that can be used to identify a joint or a group of joints.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.Anchor">
            <summary>
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.ConnectedAnchor">
            <summary>
            If the joint has a <see cref="F:Quantum.Physics3D.Joint3D.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.ConnectedEntity">
            <summary>
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics3D.Joint3D.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform3D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody3D"/>, joint forces are also computed and applied to it. 
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.SpringJoint">
            <summary>
            Type-specific settings of a joint of type <see cref="F:Quantum.Physics3D.JointType3D.SpringJoint"/>.
            <remarks>
            Different types of joints have their fields overlapping in memory.
            Thus, settings of a type different than this joint's <see cref="P:Quantum.Physics3D.Joint3D.Type"/> might have fields with unexpected values.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.DistanceJoint">
            <summary>
            Type-specific settings of a joint of type <see cref="F:Quantum.Physics3D.JointType3D.DistanceJoint"/>.
            <remarks>
            Different types of joints have their fields overlapping in memory.
            Thus, settings of a type different than this joint's <see cref="P:Quantum.Physics3D.Joint3D.Type"/> might have fields with unexpected values.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.HingeJoint">
            <summary>
            Type-specific settings of a joint of type <see cref="F:Quantum.Physics3D.JointType3D.HingeJoint"/>.
            <remarks>
            Different types of joints have their fields overlapping in memory.
            Thus, settings of a type different than this joint's <see cref="P:Quantum.Physics3D.Joint3D.Type"/> might have fields with unexpected values.
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Joint3D.Type">
            <summary>
            The type of this joint, indicating which type-specific settings should be accessed.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Joint3D.Enabled">
            <summary>
            If the constraints of this joint should be considered and resolved by the 3D Physics Engine. 
            </summary>
        </member>
        <member name="T:Quantum.Physics3D.Hit3D">
            <summary>
            Information returned from a valid hit of a physics query.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.Physics3D.Hit3D.ShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape3D.UserTag"/> field of the shape hit by the query.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Hit3D.OverlapPenetration">
            <summary>
            The penetration of a shape overlap query on the collider that was hit.
            <remarks>
            This field is not computed unless <see cref="F:Quantum.QueryOptions.ComputeDetailedInfo"/> is used in the query options
            and only applies to Shape Overlap queries.
            It overlaps in memory and is mutually exclusive with <see cref="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized"/>.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized">
            <summary>
            A normalized value (0 to 1) of the feature being casted when the hit occurs, relative to its full cast distance.
            <remarks>
            This field only applies to Ray, Line or Shape casts.
            It overlaps in memory and is mutually exclusive with <see cref="F:Quantum.Physics3D.Hit3D.OverlapPenetration"/>.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Hit3D.Point">
            <summary>
            The point in world space where the collider is hit by the query.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Hit3D.Normal">
            <summary>
            The surface normal of the hit.
            <remarks>
            This field is not computed unless <see cref="F:Quantum.QueryOptions.ComputeDetailedInfo"/> is used in the query options.
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Hit3D.IsDynamic">
            <summary>
            If the collider hit by the query is not static, i.e. it belongs to an <see cref="P:Quantum.Physics3D.Hit3D.Entity"/>.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Hit3D.StaticColliderIndex">
            <summary>
            0-based index of the static collider on the <see cref="F:Quantum.Map.StaticColliders3D"/> array of the map referenced by <see cref="P:Quantum.Physics3D.Hit3D.StaticColliderMapRef"/>.
            If the hit <see cref="P:Quantum.Physics3D.Hit3D.IsDynamic"/>, this value is -1.
            Tip: use <see cref="M:Quantum.Physics3D.Hit3D.TryGetStaticCollider(Quantum.Core.FrameBase,Quantum.MapStaticCollider3D@)"/>, <see cref="M:Quantum.Physics3D.Hit3D.TryGetStaticData(Quantum.Core.FrameBase,Quantum.StaticColliderData@)"/>, <see cref="M:Quantum.Physics3D.Hit3D.GetStaticCollider(Quantum.Core.FrameBase)"/> or <see cref="M:Quantum.Physics3D.Hit3D.GetStaticData(Quantum.Core.FrameBase)"/>
            in order to safely and conveniently access info about a static collider hit.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Hit3D.StaticColliderMapRef">
            <summary>
            The reference to the map used by the physics engine when a static collider is hit.
            Otherwise, this value is default (hit <see cref="P:Quantum.Physics3D.Hit3D.IsDynamic"/>).
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Hit3D.IsTrigger">
            <summary>
            If the collider hit by the query is Trigger.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Hit3D.Entity">
            <summary>
            The reference of the entity hit by the query, <see cref="P:Quantum.EntityRef.None"/> if hitting a static collider (<see cref="P:Quantum.Physics3D.Hit3D.IsDynamic"/> false).
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.SetHitEntity(Quantum.EntityRef)">
            <summary>
            Sets the entity that was hit. Automatically resets <see cref="P:Quantum.Physics3D.Hit3D.StaticColliderIndex"/> to -1.
            </summary>
            <param name="entity">The entity reference.</param>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.SetHitStaticCollider(System.Int32,Quantum.AssetRefMap)">
            <summary>
            Sets the index of the static collider hit on the <see cref="F:Quantum.Map.StaticColliders3D"/> array of the referenced map.
            </summary>
            <param name="staticColliderIndex">A valid index of the static collider on the array of the map.</param>
            <param name="mapRef">A reference to the map where the static collider hit is located.</param>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.TryGetStaticCollider(Quantum.Core.FrameBase,Quantum.MapStaticCollider3D@)">
            <summary>
            Tries to access the static collider that was hit.
            </summary>
            <param name="f">Current frame.</param>
            <param name="collider">A copy of the static collider data found. Default if the metadata is not valid (returns false).</param>
            <returns>False if the collider hit is not static or the collide index or referenced map are not valid. True otherwise.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.TryGetStaticData(Quantum.Core.FrameBase,Quantum.StaticColliderData@)">
            <summary>
            Tries to access the data of the static collider that was hit (<see cref="F:Quantum.MapStaticCollider3D.StaticData"/>).
            </summary>
            <param name="f">Current frame.</param>
            <param name="data">A copy of the static collider data found. Default if the metadata is not valid (returns false).</param>
            <returns>False if the collider hit is not static or the collide index or referenced map are not valid. True otherwise.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.GetStaticCollider(Quantum.Core.FrameBase)">
            <summary>
            Gets a reference to the static collider hit. Does not perform additional safety checks.
            </summary>
            <param name="f">Current frame.</param>
            <exception cref="T:System.NullReferenceException">If the <see cref="P:Quantum.Physics3D.Hit3D.StaticColliderMapRef"/> does not reference a valid asset.</exception>
            <exception cref="T:System.IndexOutOfRangeException">If the hit is not static (<see cref="P:Quantum.Physics3D.Hit3D.IsDynamic"/>) or the collider index is not valid for the array of static colliders on the referenced map.</exception>
            <returns>A reference to the static collider hit.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.GetStaticData(Quantum.Core.FrameBase)">
            <summary>
            Gets a reference to the data of the static collider hit (<see cref="F:Quantum.MapStaticCollider3D.StaticData"/>). Does not perform additional safety checks.
            </summary>
            <param name="f">Current frame.</param>
            <exception cref="T:System.NullReferenceException">If the <see cref="P:Quantum.Physics3D.Hit3D.StaticColliderMapRef"/> does not reference a valid asset.</exception>
            <exception cref="T:System.IndexOutOfRangeException">If the hit is not static (<see cref="P:Quantum.Physics3D.Hit3D.IsDynamic"/>) or the collider index is not valid for the array of static colliders on the referenced map.</exception>
            <returns>A reference to the static collider hit.</returns>
        </member>
        <member name="M:Quantum.Physics3D.HitCollection3D.Sort(Photon.Deterministic.FPVector3)">
            <summary>
            Sort all hits in the collection, in ascending order, based on the distance from the <see cref="F:Quantum.Physics3D.Hit3D.Point"/> to the target <paramref name="point"/>.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.HitCollection3D.SortCastDistance">
            <summary>
            Sort all hits in the collection, in ascending order, based on the <see cref="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized"/>.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.Scene3D.Task_CreateEntriesMapping(Quantum.FrameThreadSafe,System.Int32,System.Int32,System.Void*)">
            <summary>
            Creates a mapping from EntityRef to Entry (usable for Joints, for instance).
            Must run after <see cref="M:Quantum.Physics3D.Scene3D.Task_CreateEntries(Quantum.FrameThreadSafe,System.Int32,System.Int32,System.Void*)"/> and in a single thread.
            </summary>
        </member>
        <member name="T:Quantum.PhysicsJoints3D">
            <summary>
            A component holding one or more <see cref="T:Quantum.Physics3D.Joint3D"/>,
            defining connections between a 3D Physics Body and anchors according to velocity and/or position constraints.
            </summary>
            \ingroup PhysicsJoints3D
        </member>
        <member name="T:Quantum.PhysicsJoints3D.JointsIterator3D">
            <summary>
            An auxiliary struct to iterate over the joints on a <see cref="T:Quantum.PhysicsJoints3D"/> component.
            Use <see cref="M:Quantum.PhysicsJoints3D.GetIterator(Quantum.Core.FrameBase,System.Boolean)"/> to acquire an iterator for the component's joint buffer.
            </summary>
            <remarks>
            If new elements are added while iterating and this causes the buffer to be expanded,
            the iterator will keep iterating over the previous buffer, which is not immediately disposed (see <see cref="M:Quantum.PhysicsJoints3D.AddJoint(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@)"/>).
            In this case, further changes to elements in the buffer being iterated will not modify the elements on the new buffer.
            Hence, the addition of elements while iterating is not recommended, unless the access to the elements are read-only.
            </remarks>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            var jointsIterator  = jointsComponent->GetIterator(f);
            
            while (jointsIterator.MoveNext()) {
              // CurrentUnsafe is a pointer to the element in the buffer
              jointsIterator.CurrentUnsafe->Enabled = true;
            
              // Current is a copy of the joint being currently iterated
              var jointCopy = jointsIterator.Current;
              Assert.Check(jointCopy.Enabled);
            
              // by default, the iterator will go through the elements in reverse order.
              // this allows the removal of elements while iterating without this causing elements to be skipped as a byproduct.
              if (jointCopy.Type == Physics3D.JointType3D.None) {
                jointsComponent->RemoveAtUnordered(f, jointsIterator.CurrentIndex);
              }
            }
            </code>
            \ingroup PhysicsJoints3D
        </member>
        <member name="M:Quantum.PhysicsJoints3D.JointsIterator3D.GetEnumerator">
            <summary>
            The iterator is also an enumerator.
            This method is useful for accessing the elements in a foreach loop, for instance.
            </summary>
            <returns>A copy of this iterator on its current state.</returns>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.JointsIterator3D.MoveNext">
            <summary>
            Moves to the next joint.
            </summary>
            <returns>True if there is a next element.</returns>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.JointsIterator3D.Reset">
            <summary>
            Resets the iterator to its original state.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsJoints3D.JointsIterator3D.CurrentUnsafe">
            <summary>
            A pointer to the current joint being iterated.
            This allows modifications to the element in the actual buffer of joints.
            </summary>
            <exception cref="T:System.NullReferenceException">If the iterator buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the iterator current index is outside the valid range of the buffer: [0, count).</exception>
        </member>
        <member name="P:Quantum.PhysicsJoints3D.JointsIterator3D.Current">
            <summary>
            A copy of the current joint being iterated.
            To modify the actual element in the buffer, use <see cref="P:Quantum.PhysicsJoints3D.JointsIterator3D.CurrentUnsafe"/> instead.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsJoints3D.JointsIterator3D.CurrentIndex">
            <summary>
            The index on the buffer of the element currently being iterated.
            The index is out of the valid range if the iterator has just been created on <see cref="M:Quantum.PhysicsJoints3D.JointsIterator3D.Reset"/>.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.GetIterator(Quantum.Core.FrameBase,System.Boolean)">
            <summary>
            Gets an auxiliary struct to iterate over the joints in this component.
            See also <see cref="M:Quantum.PhysicsJoints3D.TryGetJoints(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D*@,System.Int32@)"/> and <see cref="M:Quantum.PhysicsJoints3D.GetJoints(Quantum.Core.FrameBase,System.Int32@)"/> to have direct access to the buffer.
            </summary>
            <remarks>
            If new elements are added while iterating and this causes the buffer to be expanded,
            the iterator will keep iterating over the previous buffer, which is not immediately disposed (see <see cref="M:Quantum.PhysicsJoints3D.AddJoint(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@)"/>).
            In this case, further changes to elements in the buffer being iterated will not modify the elements on the new buffer.
            Hence, the addition of elements while iterating is not recommended, unless the access to the elements are read-only.
            </remarks>
            <param name="f">The current frame.</param>
            <param name="reverseOrder">
            If the buffer elements should be iterated in reverse order.
            If true, allows the removal of elements while iterating without it causing some elements to be skipped.
            </param>
            <returns>A <see cref="T:Quantum.PhysicsJoints3D.JointsIterator3D"/> for the buffer of joints in this component.</returns>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            var jointsIterator  = jointsComponent->GetIterator(f);
            
            while (jointsIterator.MoveNext()) {
              // CurrentUnsafe is a pointer to the element in the buffer
              jointsIterator.CurrentUnsafe->Enabled = true;
            
              // Current is a copy of the joint being currently iterated
              var jointCopy = jointsIterator.Current;
              Assert.Check(jointCopy.Enabled);
            
              // by default, the iterator will go through the elements in reverse order.
              // this allows the removal of elements while iterating without this causing elements to be skipped as a byproduct.
              if (jointCopy.Type == Physics3D.JointType3D.None) {
                jointsComponent->RemoveAtUnordered(f, jointsIterator.CurrentIndex);
              }
            }
            </code>
        </member>
        <member name="P:Quantum.PhysicsJoints3D.Count">
            <summary>
            The current amount of joints tracked by the component.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsJoints3D.Capacity">
            <summary>
            The number of joints the currently allocated buffer can hold before having to be resized.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.AddJoint(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@)">
            <summary>
            Adds a <see cref="T:Quantum.Physics3D.Joint3D"/> to the component.
            If the buffer is at full <see cref="P:Quantum.PhysicsJoints3D.Capacity"/>, a new buffer will be allocated with double the capacity and existing entries are copied over.
            In that case, the previous buffer is not disposed immediately and cached pointers are still valid, although outdated.
            </summary>
            <param name="f">The current frame.</param>
            <param name="joint">The joint that will be added to the component.</param>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.RemoveJoints(Quantum.Core.FrameBase,System.Nullable{System.Int32})">
            <summary>
            Removes all joints in the component that have a <see cref="F:Quantum.Physics3D.Joint3D.UserTag"/> field matching the specified <paramref name="userTag"/>.
            If none is specified, all joints are removed.
            </summary>
            <remarks>
            This method does not keep the order of remaining elements in the buffer.
            To achieve that instead, use <see cref="M:Quantum.PhysicsJoints3D.GetJoints(Quantum.Core.FrameBase,System.Int32@)"/> and <see cref="M:Quantum.PhysicsJoints3D.RemoveAt(Quantum.Core.FrameBase,System.Int32)"/> while iterating the buffer in reverse order.
            </remarks>
            <param name="f">The current frame.</param>
            <param name="userTag">
            A numerical tag that can be used to identify a joint or a group of joints.
            Any joint in the component that matches the tag will be removed.
            If none is specified, all joints are removed.
            </param>
            <returns>True if at least one joint has been removed.</returns>
            <code>
            const int removeJointsUserTag = 42;
            
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            if (removeAll) {
              jointsComponent->RemoveJoints(f);
            } else {
              jointsComponent->RemoveJoints(f, removeJointsUserTag);
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.RemoveAt(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Removes the joint at the specified <paramref name="index"/> of the component's joints buffer, while keeping the order of the remaining objects.
            If the remaining elements do not need to be kept in order, <see cref="M:Quantum.PhysicsJoints3D.RemoveAtUnordered(Quantum.Core.FrameBase,System.Int32)"/> is a cheaper option.
            </summary>
            <param name="f">The current frame.</param>
            <param name="index">The index of the element to be removed.</param>
            <exception cref="T:System.NullReferenceException">If the joints buffer is not allocated.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the <paramref name="index"/> is outside the valid range.</exception>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            
            if (jointsComponent->TryGetJoints(f, out var joints, out var count)) {
              // by iterating the buffer in reverse order we avoid skipping elements if also removing
              for (var i = count - 1; i >= 0; i--) {
                var current = joints + i;
            
                if (current->Type == Physics3D.JointType3D.DistanceJoint) {
                  // removes the element at the current index, keeping the order of the remaining ones
                  jointsComponent->RemoveAt(f, i);
                }
              }
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.RemoveAtUnordered(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Removes the joint at the specified <paramref name="index"/> of the component's joints buffer.
            The order of the elements with indices greater than <paramref name="index"/> is not kept.
            If the order must be kept, use <see cref="M:Quantum.PhysicsJoints3D.RemoveAt(Quantum.Core.FrameBase,System.Int32)"/> instead.
            </summary>
            <param name="f">The current frame.</param>
            <param name="index">The index of the element to be removed.</param>
            <exception cref="T:System.NullReferenceException">If the joints buffer is not allocated.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the <paramref name="index"/> is outside the valid range.</exception>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            
            if (jointsComponent->TryGetJoints(f, out var joints, out var count)) {
              // by iterating the buffer in reverse order we avoid skipping elements if also removing
              for (var i = count - 1; i >= 0; i--) {
                var current = joints + i;
            
                if (current->Type == Physics3D.JointType3D.DistanceJoint) {
                  // removes the element at the current index
                  // the order of the elements with index greater than i is not ensured
                  jointsComponent->RemoveAtUnordered(f, i);
                }
              }
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.TryGetJoints(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D*@,System.Int32@)">
            <summary>
            Gets the currently allocated buffer for the component joints, if it has one.
            See also <see cref="M:Quantum.PhysicsJoints3D.GetIterator(Quantum.Core.FrameBase,System.Boolean)"/> to iterate over the buffer with an auxiliary structure.
            </summary>
            <param name="f">The current frame.</param>
            <param name="joints">The allocated buffer for the component joints. Null if the buffer is not allocated.</param>
            <param name="count">The number of elements used in the buffer at the moment this method is called. 0 if the buffer is not allocated.</param>
            <returns>True if the buffer is allocated.</returns>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            
            if (jointsComponent->TryGetJoints(f, out var joints, out var count)) {
              for (var i = 0; i &lt; count; i++) {
                var current = joints + i;
                Log.Info($"Joint Type {i}: {current->Type}");
              }
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.GetJoints(Quantum.Core.FrameBase,System.Int32@)">
            <summary>
            Gets the currently allocated buffer for the component joints.
            See also <see cref="M:Quantum.PhysicsJoints3D.GetIterator(Quantum.Core.FrameBase,System.Boolean)"/> to iterate over the buffer with an auxiliary structure.
            </summary>
            <param name="f">The current frame.</param>
            <param name="count">The number of elements used in the buffer at the moment this method is called.</param>
            <returns>The allocated buffer for the component joints.</returns>
            <exception cref="T:System.NullReferenceException">If the buffer is not allocated.</exception>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            var joints = jointsComponent->GetJoints(f, out var count);
            
            for (var i = 0; i &lt; count; i++) {
              var current = joints + i;
              Log.Info($"Joint Type {i}: {current->Type}");
            }
            </code>
        </member>
        <member name="T:Quantum.PhysicsCommon.Config">
            <summary>
            Global physics settings which are part of the <see cref="!:SimulationConfig"/>.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.Gravity">
            <summary>
            Define the gravity of the physics simulation. For a 2D world set the y-component to zero.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.SolverIterations">
            <summary>
            The physics collision solver runs in sub-steps to improve quality.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.PositionSolverIterations">
            <summary>
            The physics position constraint solver (used on Joint, for instance) runs in sub-steps to improve quality.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.UseJoints">
            <summary>
            Enable the use of joints in the physics engines. If joints are not used, this can be disabled to reduce overhead.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.UseAngularVelocity">
            <summary>
            Lock the angular velocity for dynamic bodies. Disabling this option leads not only to faster but also to more stable physics simulation for games that can use it.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.UseVerticalTransform">
            <summary>
            Toggle the use of a vertical transform component for 2.5D worlds that have a simplified concept of height.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.PenetrationAllowance">
            <summary>
            Allow a certain degree of penetration to improve the stability of the physics simulation.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.PenetrationCorrection">
            <summary>
            How much of the exceeding penetration (above allowance) should be corrected in a single frame. 0 = no correction, 1 = full correction.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.MinLinearIntegration">
            <summary>
            A physics body's linear velocity component (x, y or z, the latter only in the 3D Physics) is rounded to 0 if its absolute value is smaller than this minimum linear integration.
            A small amount can increase the physics simulation stability and improve sleep detection.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.MinAngularIntegration">
            <summary>
            A physics body's angular velocity component (x, y or z in the 3D Physics and the amount relative to the vertical axis in the 2D Physics) is rounded to 0 if its absolute value is smaller than this minimum angular integration.
            A small amount can increase the physics simulation stability and improve sleep detection.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.SimplexMinBitShift">
            <summary>
            Scales the GJK Voronoy Simplex space by shifting points' raw values. Consider increasing if working with small-scaled shapes.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.SimplexMaxBitShift">
            <summary>
            The GJK Voronoy Simplex space is scaled by progressively by shifting points' raw values up to this max value when the current instance becomes affine dependent, avoiding degenerate cases due to limited precision.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.ShapeCastMaxIterations">
            <summary>
            The max number of iterations performed by the GJK algorithm while searching for a solution below <see cref="F:Quantum.PhysicsCommon.Config.ShapeCastHardTolerance"/>.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.ShapeCastHardTolerance">
            <summary>
            A GJK iteration result below this threshold is acceptable as a finishing condition.
            In general, increasing the hard tolerance decreases the accuracy of the result, but reduces computational cost by requiring less iterations.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.ShapeCastSoftTolerance">
            <summary>
            A GJK resolution that fails to find an acceptable result below <see cref="F:Quantum.PhysicsCommon.Config.ShapeCastHardTolerance"/> after <see cref="F:Quantum.PhysicsCommon.Config.ShapeCastMaxIterations"/>
            will still return positive if the best solution found is below this soft threshold.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.AllowSleeping">
            <summary>
            Toggles the detection of physics bodies in a sleeping state.
            If allowed, the simulation will skip forces and velocity integrations and collisions detection on physics bodies while they are asleep.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.SleepTimeSec">
            <summary>
            For how many seconds a physics body should stay under the linear and angular velocity sleeping thresholds before being put in a sleeping state.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.LinearSleepTolerance">
            <summary>
            Amount of linear velocity below which a physics body might be considered as standing still for sleeping detection.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.AngularSleepToleranceInRad">
            <summary>
            Amount of angular velocity below which a physics body might be considered as standing still for sleeping detection.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.AllowCCD">
            <summary>
            Allows CCD to be performed if the Physics Body has CCD enabled on its Config flags.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.CCDLinearVelocityThreshold">
            <summary>
            If CCD is allowed, it will be performed on all Physics Bodies that have it enabled and have a linear velocity magnitude above this threshold.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.CCDAngularVelocityThreshold">
            <summary>
            If CCD is allowed, it will be performed on all Physics Bodies that have it enabled and have a angular velocity magnitude above this threshold.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.CCDDistanceTolerance">
            <summary>
            The absolute distance value below which the Physics Bodies under CCD check can be considered as touching.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.MaxTimeOfImpactIterations">
            <summary>
            The maximum number of iterations performed by the CCD algorithm when computing the time of impact between two Physics Bodies.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.MaxRootFindingIterations">
            <summary>
            The maximum number of iterations performed when computing the point in time when the distance between two Physics Bodies in a given separation axis is below the tolerance.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultPhysicsMaterial">
            <summary>
            The default <see cref="T:Quantum.PhysicsMaterial"/> asset used when initializing a 2D or 3D physics collider component with no other material specified
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultCharacterController2D">
            <summary>
            The default <see cref="T:Quantum.CharacterController2DConfig"/> asset used when initializing a CharacterController2D component with no other config specified
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultCharacterController3D">
            <summary>
            The default <see cref="T:Quantum.CharacterController3DConfig"/> asset used when initializing a CharacterController3D component with no other config specified
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.Layers">
            <summary>
            The collision layer names recognized by the Quantum simulation. Can be imported from Unity layers on the editor.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.LayerMatrix">
            <summary>
            The collision matrix of the layers recognized by the Quantum simulation. Can be imported from Unity's layer matrix on the editor.
            </summary>
        </member>
        <member name="T:Quantum.NavMeshSteeringAgent">
            <summary>
            Requires NavMeshPathfinder component.
            </summary>
            \ingroup NavigationApi
        </member>
        <member name="P:Quantum.NavMeshSteeringAgent.Acceleration">
            <summary>
            Agent acceleration value.
            </summary>
            <remarks>Is potentially set to its original config value <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>. </remarks>
        </member>
        <member name="P:Quantum.NavMeshSteeringAgent.CurrentSpeed">
            <summary>
            The current speed per second that the agent is moving.
            </summary>
            <remarks>Performs FPMath.Sqrt or the Velocity internally.</remarks>
            <remarks>Is potentially set to its original config value <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>. </remarks>
        </member>
        <member name="P:Quantum.NavMeshSteeringAgent.MaxSpeed">
            <summary>
            Agent max speed value.
            </summary>
            <remarks>Is potentially set to its original config value <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>. </remarks>
        </member>
        <member name="P:Quantum.NavMeshSteeringAgent.Velocity">
            <summary>
            The current linear velocity of the agents. This is set from the internal steering.
            </summary>
        </member>
        <member name="T:Quantum.NavMeshAgentSteeringData">
            <summary>
            Navmesh agent steering data passed into callbacks.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentSteeringData.Waypoint">
            <summary>
            Current waypoint position.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentSteeringData.Flags">
            <summary>
            Is the current waypoint the target.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentSteeringData.DesiredDirection">
            <summary>
            The velocity the agent desires to move influenced by avoidance (if enabled). The velocity is normalized over the current speed.
            </summary>
        </member>
        <member name="T:Quantum.NavMeshRegionMask">
            <summary>
            Internally stores a unsigned long to be able to toggle 64 different regions. 
            </summary>
            <remarks>When instantiating a NavMeshRegionMask, all regions are toggled off.</remarks>
            <remarks>Use <see cref="P:Quantum.NavMeshRegionMask.Default"/> to create a mask with all regions toggled on.</remarks>
            <example><code>
            // Toggle a region per frame
            f.NavMeshRegionMask->ToggleRegion(cmd.Region, !f.NavMeshRegionMask->IsRegionEnabled(cmd.Region));
            // Check if a region id is active
            var isRegionActive = f.NavMeshRegionMask-&gt;IsRegionEnabled(regionId);
            // Check if a NavMeshRegionMask (found on the pathfinder component) is active
            var isRegionAcitve = f.Unsafe.GetPointer&lt;NavMeshPathfinder&gt;(entity)-&gt;RegionMask.IsSubset(*f.NavMeshRegionMask);
            </code></example>
        </member>
        <member name="P:Quantum.NavMeshRegionMask.Default">
            <summary>
            All regions toggled on.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Combine(Quantum.NavMeshRegionMask,Quantum.NavMeshRegionMask)">
            <summary>
            Combine two region masks. 
            </summary>
            <param name="a">A</param>
            <param name="b">B</param>
            <returns>A region must be active in both masks for be toggled on on the resulting mask.</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.#ctor(System.UInt64)">
            <summary>
            Constructor.
            </summary>
            <param name="regions">Raw region mask</param>
        </member>
        <member name="P:Quantum.NavMeshRegionMask.HasValidRegions">
            <summary>
            Returns true, when the mask has exactly one valid region set.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshRegionMask.IsMainArea">
            <summary>
            Checks if the mask is zero which will be true for triangles belonging to the main navmesh area and cannot be toggled off.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshRegionMask.Mask">
            <summary>
            Access to underlying bit mask.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.ToggleRegion(System.Int32,System.Boolean)">
            <summary>
            Toggle a region by id (or index).
            </summary>
            <param name="region">Region id (defined by the region list inside the Map)</param>
            <param name="enabled">Toggle region on or off</param>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.IsRegionEnabled(System.Int32)">
            <summary>
            Check if a region is active.
            </summary>
            <param name="region">Region id (or index)</param>
            <returns>True if the region is active.</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.IsSubset(Quantum.NavMeshRegionMask)">
            <summary>
            Check if the region mask is included inside the other.
            </summary>
            <param name="other">Other mask, usually the one from Frame</param>
            <returns>True if all regions are included in other</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.IsSuperset(Quantum.NavMeshRegionMask)">
            <summary>
            Check is the region mask of other is included in ours.
            </summary>
            <param name="other">Other region mask</param>
            <returns>True if all regions inside the other mask are also active in ours</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Clear">
            <summary>
            This sets all regions to active.
            </summary>
        </member>
        <member name="T:Quantum.CharacterController2DMovement">
            <summary>
            Result of a 2D KCC raw movement query.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.Type">
            <summary>
            Recommended type of movement based on found collisions.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.NearestNormal">
            <summary>
            Surface normal of the nearest collision.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.AvgNormal">
            <summary>
            Average normal of all collisions.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.GroundNormal">
            <summary>
            Surface normal of the closest collision that qualifies as ground, if any.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.Tangent">
            <summary>
            Surface tangent (recommended movement direction) in case there's a desired direction passed.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.SlopeTangent">
            <summary>
            Surface tangent (recommended movement direction) in case of a slope (based on gravity).
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.Correction">
            <summary>
            Full correction vector to move out of collisions.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.Penetration">
            <summary>
            Magnitude of the penetration over the nearest normal.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.Grounded">
            <summary>
            True if at least one collision (not necessarily closest) qualifies as ground.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.Contacts">
            <summary>
            Total number of collisions found in this execution of the movement query.
            </summary>
        </member>
        <member name="T:Quantum.CharacterController2D">
            <summary>
            
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="P:Quantum.CharacterController2D.Jumped">
            <summary>
            If the character jumped this frame. See <see cref="M:Quantum.CharacterController2D.Jump(Quantum.Core.FrameBase,System.Boolean,System.Nullable{Photon.Deterministic.FP})"/>.
            <remarks>This state is consumed in the default steering method <see cref="M:Quantum.CharacterController2D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>.</remarks>
            </summary>
        </member>
        <member name="P:Quantum.CharacterController2D.BroadPhaseQueryIndex">
            <summary>
            The index of the Broad-Phase Query added by calling <see cref="M:Quantum.CharacterController2D.AddBroadPhaseQuery(Quantum.Core.FrameBase,Quantum.EntityRef,System.Nullable{System.Int32})"/>, -1 if no query has been added.
            This index will be used on the next time Move or ComputeRawMovement is called, to retrieve the resolved query results, and is automatically reset when that happens.
            Set this value to -1 in order to not use the BP Query result in the KCC movement. In this case a regular query will be performed, as by default.
            </summary>
        </member>
        <member name="M:Quantum.CharacterController2D.Init(Quantum.Core.FrameBase,Quantum.CharacterController2DConfig)">
            <summary>
            Initializes the 2D character controller component.
            <remarks>This method is not thread-safe. Use the thread-safe overload if calling from a threaded context.</remarks>
            </summary>
            <remarks>Can be used to reset the kcc config.</remarks>
            <param name="frame">The frame object.</param>
            <param name="config">The KCC <see cref="T:Quantum.CharacterController2DConfig"/> asset. If none is provided, the default asset is used.</param>
        </member>
        <member name="M:Quantum.CharacterController2D.Jump(Quantum.Core.FrameBase,System.Boolean,System.Nullable{Photon.Deterministic.FP})">
            <summary>
            Applies a vertical impulse to the KCC velocity.
            <remarks>This method is not thread-safe. Use the thread-safe overload if calling from a threaded context.</remarks>
            </summary>
            <remarks>No steering is performed at this stage. To actually move the character, use <see cref="M:Quantum.CharacterController2D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>.</remarks>
            <param name="frame">The frame object.</param>
            <param name="ignoreGrounded">If the <see cref="P:Quantum.CharacterController2D.Grounded"/> state of the KCC should be ignored.</param>
            <param name="impulse">The amount of impulse applied to the KCC. If none is provided, the <see cref="F:Quantum.CharacterController2DConfig.BaseJumpImpulse"/> of the KCC config is used.</param>
        </member>
        <member name="M:Quantum.CharacterController2D.AddBroadPhaseQuery(Quantum.Core.FrameBase,Quantum.EntityRef,System.Nullable{System.Int32})">
            <summary>
            Adds a Broad-phase query to the 2D Physics scene, according to the KCC config settings, and store the query index in <see cref="P:Quantum.CharacterController2D.BroadPhaseQueryIndex"/>.
            This index will be used on the next time Move or ComputeRawMovement is called, to retrieve the resolved query results and perform the KCC logic.
            </summary>
            <remarks>
            The added BP-Query must be retrieve on the same frame. To cancel the addition of a BP-Query and perform a regular one when moving the KCC, set <see cref="P:Quantum.CharacterController2D.BroadPhaseQueryIndex"/> to -1. 
            </remarks>
            <param name="frame">The current frame object.</param>
            <param name="entity">
            The entity that represents the character. It must have a <see cref="T:Quantum.Transform2D"/> component, which will be used to compute the query position,
            along with a <see cref="T:Quantum.Transform2DVertical"/> (optional), if the entity has one.
            </param>
            <param name="layerMask">A mask that specifies which layers should be considered by the query. If null (default), the layer maks defined in the KCC config will be used.</param>
            <returns>The index of the added query.</returns>
        </member>
        <member name="M:Quantum.CharacterController2D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})">
            <summary>
            Queries the 2D physics scene with <see cref="M:Quantum.CharacterController2D.ComputeRawMovement(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Transform2D*,Quantum.CharacterController2D*,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},Photon.Deterministic.FP,Photon.Deterministic.FP)"/>, computes a default steering in the desired <paramref name="direction"/> and moves the <paramref name="entity"/>.
            <remarks>This method is not thread-safe. Use the thread-safe overload if calling from a threaded context.</remarks>
            </summary>
            <remarks>The entity must have a Transform2D component.</remarks>
            <param name="frame">The frame in which the entity is being moved.</param>
            <param name="entity">The entity that represents the character. Any collider attached by this entity is ignored in the raw movement computation.</param>
            <param name="direction">The intended movement direction.</param>
            <param name="callback">An object that can receive the KCC callbacks. If calling from a system that implements the interface, you can use the "this" keyword.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against in the raw movement computation.
            If null is passed, the layer maks defined in the KCC config will be used. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="useManifoldNormal">
            If the hit manifold normal should be used when computing the raw movement.
            If false, the normal is computed from the query position and the contact point.
            If no value is provided, the <see cref="F:Quantum.CharacterController2DConfig.UseManifoldNormal"/> of the KCC config is used.
            </param>
            <param name="deltaTime">The delta timed used to integrate the kcc velocity. If no value is provided, the <paramref name="frame"/> delta time is used.</param>
        </member>
        <member name="M:Quantum.CharacterController2D.ComputeRawMovement(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Transform2D*,Quantum.CharacterController2D*,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene in the <paramref name="transform"/> position, using the <paramref name="kcc"/> config, and computes movement data.
            The movement data can be used to apply a custom steering to the character based on its surrounding environment.
            For using the default steering, use <see cref="M:Quantum.CharacterController2D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>.
            <remarks>This method is not thread-safe. Use the thread-safe overload if calling from a threaded context.</remarks>
            </summary>
            <param name="frame">The frame in which the physics scene is being queried.</param>
            <param name="entity">The entity that represents the character. Any collider attached by this entity is ignored in the raw movement computation.</param>
            <param name="transform">A pointer to a Transform2D component that has the position where the scene will be queried at, usually being the <paramref name="entity"/> transform.</param>
            <param name="kcc">A pointer to a CharacterController2D component that has the config used by the query, usually being the <paramref name="entity"/> kcc component.</param>
            <param name="direction">The intended movement direction.</param>
            <param name="callback">An object that can receive the KCC callbacks.
            <remarks>If calling from a system that implements the interface, you can use the "this" keyword.</remarks>
            </param>
            <param name="layerMask">A mask that specifies which layers will be checked against in the raw movement computation.
            If null is passed, the layer maks defined in the KCC config will be used. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="useManifoldNormal">
            If the hit manifold normal should be used when computing the raw movement.
            If false, the normal is computed from the query position and the contact point.
            If no value is provided, the <see cref="F:Quantum.CharacterController2DConfig.UseManifoldNormal"/> of the KCC config is used.
            </param>
            <param name="verticalPosition">The 2.5D vertical position where the 2D KCC query will be performed.</param>
            <param name="verticalHeight">The 2.5D vertical height with which the 2D KCC query will be performed.</param>
            <returns>A <see cref="T:Quantum.CharacterController2DMovement"/> struct with raw movement data that can be used to compute a custom steering.</returns>
        </member>
        <member name="F:Quantum.PhysicsBody2D.ConfigFlags.Default">
            <summary>IsAllowedToSleep | IsAwakenedByForces | ResetInertiaOnAdded | ResetCenterOfMassOnAdded</summary>
        </member>
        <member name="M:Quantum.PhysicsBody2D.ResetInertia(Quantum.Core.FrameBase,Quantum.EntityRef)">
            <summary>
            Resets the inertia on this physics body component based on its mass and the shape of a
            <see cref="T:Quantum.PhysicsCollider2D"/> component on the <paramref name="entity"/>.
            <remarks>
            This is called automatically when a <see cref="T:Quantum.PhysicsBody2D"/> component is added to an entity, unless the body <see cref="F:Quantum.PhysicsBody2D.ConfigFlags.ResetInertiaOnAdded"/> flag is not set.
            The body's center of mass affects the computation of the inertia, so consider calling
            <see cref="M:Quantum.PhysicsBody2D.ResetCenterOfMass(Quantum.Core.FrameBase,Quantum.EntityRef)"/> before resetting the inertia, specially if the collider shape has changed.
            More info on the online docs <a href="https://doc.photonengine.com/en-us/quantum/v2/manual/physics/collider-body#changing_the_shape_at_runtime">here</a>.
            </remarks>
            </summary>
            <param name="frame">Current frame instance in use.</param>
            <param name="entity">The entity from which the collider shape will be retrieved, necessary for computing the inertia.</param>
        </member>
        <member name="M:Quantum.PhysicsBody2D.ResetCenterOfMass(Quantum.Core.FrameBase,Quantum.EntityRef)">
            <summary>
            Resets the <see cref="F:Quantum.PhysicsBody2D.CenterOfMass"/> of physics body component to the the shape <see cref="F:Quantum.Shape2D.Centroid">centroid</see>
            of a <see cref="T:Quantum.PhysicsCollider2D"/> component attached to the <paramref name="entity"/>.
            <remarks>
            This is called automatically when a <see cref="T:Quantum.PhysicsBody2D"/> component is added to an entity,
            unless the body <see cref="F:Quantum.PhysicsBody2D.ConfigFlags.ResetCenterOfMassOnAdded"/> flag is not set.
            When changing the collider shape in runtime, consider resetting the center of mass and inertia of the attached physics body,
            in this order. More info on the online docs <a href="https://doc.photonengine.com/en-us/quantum/v2/manual/physics/collider-body#changing_the_shape_at_runtime">here</a>.
            </remarks>
            </summary>
            <param name="f">Current frame instance in use.</param>
            <param name="entity">The entity from which the collider component and shape will be retrieved.</param>
        </member>
        <member name="M:Quantum.PhysicsBody2D.GetPointVelocity(Photon.Deterministic.FPVector2,Quantum.Transform2D*)">
            <summary>
            Computes the velocity of the physics body at a given <paramref name="point"/> defined in world space.
            </summary>
            <param name="point">The point where the velocity will be computed at, in world space.</param>
            <param name="bodyTransform">The transform component of the entity to which this physics body belongs.</param>
            <returns>A 2D vector representing the computed velocity, also in world space.</returns>
        </member>
        <member name="M:Quantum.PhysicsBody2D.GetRelativePointVelocity(Photon.Deterministic.FPVector2,Quantum.Transform2D*)">
            <summary>
            Computes the velocity of the physics body at a given <paramref name="point"/> defined on its local space.
            </summary>
            <param name="point">The point where the velocity will be computed at, in local space.</param>
            <param name="bodyTransform">The transform component of the entity to which this physics body belongs.</param>
            <returns>A 2D vector representing the computed velocity, in world space.</returns>
        </member>
        <member name="M:Quantum.PhysicsBody2D.Sleep">
            <summary>
            Puts an enabled physics body into a sleeping state.
            <remarks>
            If set during a physics collision callback, the body might be awakened by the solver if the collision is not ignored.  
            </remarks>
            </summary>
        </member>
        <member name="T:Quantum.StaticColliderData">
            <summary>
            Information about a static collider.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.Name">
            <summary>
            The name of the static baked into the map asset. By default is the name of the GameObject that has the static collider component.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.Tag">
            <summary>
            The tag of the static baked into the map asset. By default is the tag of the GameObject that has the static collider component.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.Layer">
            <summary>
            The layer of the static baked into the map asset. By default is the layer of the GameObject that has the static collider component.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.Asset">
            <summary>
            A reference to an asset that can be linked to the static collider. By default, no asset is linked to the collider.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.IsTrigger">
            <summary>
            If the static collider is trigger.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.ColliderIndex">
            <summary>
            0-based index of the collider in the Map <see cref="F:Quantum.Map.StaticColliders2D"/> or <see cref="F:Quantum.Map.StaticColliders3D"/> array.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.MutableMode">
            <summary>
            If the static collider can be enabled/disabled in runtime and, if so, its starting state. 
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCollider2D.Enabled">
            <summary>
            If this component should be considered by the Physics Engine.
            <remarks>
            Disabling a collider has immediate effect: queries will not find it, nor will collisions be solved nor callbacks called.
            Re-enabling, on the other hand, is deferred to the next Physics Update.
            </remarks>
            </summary>
        </member>
        <member name="T:Quantum.ExitInfo2D">
            <summary>
            Info about two entities that were colliding in the 2D Physics.
            </summary>
            <remarks>The info is taken from the perspective of the entity that has subscribed to the callback with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
            <remarks>See <see cref="T:Quantum.CollisionInfo2D"/> for 2D collisions and <see cref="T:Quantum.TriggerInfo2D"/> for 2D trigger collisions.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="P:Quantum.ExitInfo2D.Entity">
            <summary>
            The main entity that was involved in the collision.
            </summary>
            <remarks>The info is taken from the perspective of this entity, which has subscribed to the callback with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
        </member>
        <member name="P:Quantum.ExitInfo2D.Other">
            <summary>
            The other entity that was involved in the collision if the <see cref="P:Quantum.ExitInfo2D.Entity"/> was NOT colliding with a static (check <see cref="P:Quantum.ExitInfo2D.IsStatic"/>).
            </summary>
            <remarks>If the <see cref="P:Quantum.ExitInfo2D.Entity"/> was colliding with a static, Other has <see cref="P:Quantum.EntityRef.None"/> value.</remarks>
        </member>
        <member name="P:Quantum.ExitInfo2D.IsStatic">
            <summary>
            If the <see cref="P:Quantum.ExitInfo2D.Entity"/> was touching a static collider.
            If so, <see cref="P:Quantum.ExitInfo2D.Other"/> has an <see cref="P:Quantum.EntityRef.None"/> value and the static collider data can be accessed through <see cref="P:Quantum.ExitInfo2D.StaticData"/>.
            </summary>
            <code>
            if (info.IsStatic) {
              var otherStaticData = info.StaticData;
            } else {
              var otherEntity = info.Other;
            }
            </code>
        </member>
        <member name="P:Quantum.ExitInfo2D.StaticData">
            <summary>
            The <see cref="T:Quantum.StaticColliderData"/> of the static collider if the <see cref="P:Quantum.ExitInfo2D.Entity"/> was colliding with a static (check <see cref="P:Quantum.ExitInfo2D.IsStatic"/>).
            </summary>
        </member>
        <member name="T:Quantum.CollisionInfo2D">
            <summary>
            Info about a collision between two 2D physics colliders.
            </summary>
            <remarks>The info is taken from the perspective of the entity that has subscribed to the callback with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
            <remarks>See <see cref="T:Quantum.CollisionInfo3D"/> for 3D collisions and <see cref="T:Quantum.TriggerInfo2D"/> for 2D trigger collisions.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="P:Quantum.CollisionInfo2D.ContactPointIterator2D.Count">
            <summary>
            The number of contact points on this collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.ContactPointIterator2D.Average">
            <summary>
            The average contact point on this collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.ContactPointIterator2D.First">
            <summary>
            The first contact point computed on this collision.
            <remarks>Contact points are computed in NO particular order.</remarks>
            </summary>
        </member>
        <member name="M:Quantum.CollisionInfo2D.ContactPointIterator2D.Next(Photon.Deterministic.FPVector2@)">
            <summary>
            Iterates through the contact points of a collision.
            </summary>
            <param name="contactPoint">The current contact point. Default if the iteration is over.</param>
            <returns>True if there is still a <paramref name="contactPoint"/>.</returns>
            <code>
            while(info.ContactPoints.Next(out var cp) {
              Draw.Circle(cp, FP._0_10);
            }
            </code>
        </member>
        <member name="M:Quantum.CollisionInfo2D.ContactPointIterator2D.Next(Photon.Deterministic.FPVector2@,Photon.Deterministic.FPVector2@)">
            <summary>
            Iterates through the contact points of a collision, also accessing the contact normal.
            </summary>
            <param name="contactPoint">The current contact point. Default if the iteration is over.</param>
            <param name="contactNormal">The contact normal. Default if the iteration is over.</param>
            <returns>True if there is still a <paramref name="contactPoint"/> and <paramref name="contactNormal"/>.</returns>
            <code>
            while(info.ContactPoints.Next(out var contactPoint, out var contactNormal) {
               Draw.Circle(contactPoint, FP._0_10);
               Draw.Ray(contactPoint, contactNormal);
            }
            </code>
        </member>
        <member name="M:Quantum.CollisionInfo2D.ContactPointIterator2D.ResetIterator">
            <summary>
            Resets the iterator.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.IgnoreCollision">
            <summary>
            If the collision should be ignored by the physics engine.
            </summary>
        </member>
        <member name="F:Quantum.CollisionInfo2D.ContactPoints">
            <summary>
            Data about the contact points of the collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.ContactNormal">
            <summary>
            The contact normal, from the <see cref="P:Quantum.CollisionInfo2D.Entity"/> perspective.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.Penetration">
            <summary>
            The collision penetration in the <see cref="P:Quantum.CollisionInfo2D.ContactNormal"/> direction.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.IsStatic">
            <summary>
            If the <see cref="P:Quantum.CollisionInfo2D.Entity"/> is touching a static collider.
            If so, <see cref="P:Quantum.CollisionInfo2D.Other"/> has an <see cref="P:Quantum.EntityRef.None"/> value and the static collider data can be accessed through <see cref="P:Quantum.CollisionInfo2D.StaticData"/>.
            </summary>
            <code>
            if (info.IsStatic) {
              var otherStaticData = info.StaticData;
            } else {
              var otherEntity = info.Other;
            }
            </code>
        </member>
        <member name="P:Quantum.CollisionInfo2D.Entity">
            <summary>
            The main entity involved in the collision.
            </summary>
            <remarks>The info is taken from the perspective of this entity, which has subscribed to the callback with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
        </member>
        <member name="P:Quantum.CollisionInfo2D.EntityShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape2D.UserTag"/> of the entity's shape involved in the collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.Other">
            <summary>
            The other entity involved in the collision if the <see cref="P:Quantum.CollisionInfo2D.Entity"/> is NOT colliding with a static (check <see cref="P:Quantum.CollisionInfo2D.IsStatic"/>).
            </summary>
            <remarks>If the <see cref="P:Quantum.CollisionInfo2D.Entity"/> is colliding with a static, Other has <see cref="P:Quantum.EntityRef.None"/> value.</remarks>
        </member>
        <member name="P:Quantum.CollisionInfo2D.OtherShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape2D.UserTag"/> of the other entity's shape involved in the collision.
            Returns default value if the this is a static collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.StaticData">
            <summary>
            The <see cref="T:Quantum.StaticColliderData"/> of the static collider if the <see cref="P:Quantum.CollisionInfo2D.Entity"/> is colliding with a static (check <see cref="P:Quantum.CollisionInfo2D.IsStatic"/>).
            </summary>
        </member>
        <member name="T:Quantum.Shape2D">
            <summary>
            Defines a 2D shape with <see cref="P:Quantum.Shape2D.Type"/> and data disposed in a union-like structure.
            All shapes have a <see cref="F:Quantum.Shape2D.UserTag"/>, <see cref="F:Quantum.Shape2D.BroadRadius"/> and <see cref="F:Quantum.Shape2D.Centroid"/>.
            All non-compound shapes have a <see cref="F:Quantum.Shape2D.LocalTransform"/> and their <see cref="F:Quantum.Shape2D.Centroid"/> always match their local transform position.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="T:Quantum.Shape2D.CompoundShape2D">
            <summary>
            A 2D shape type that can reference a group of other 2D shapes (including other compounds).
            Compound shape overlaps and physics colliders with compound shapes are supported.
            </summary>
        </member>
        <member name="P:Quantum.Shape2D.CompoundShape2D.IsPersistent">
            <summary>
            If the buffer of shapes is persistently allocated.
            </summary>
            <remarks>Persistently allocated memory is not disposed automatically. Call <see cref="M:Quantum.Shape2D.CompoundShape2D.FreePersistent(Quantum.Core.FrameBase,System.Boolean)"/> when done using a persistent compound.</remarks>
        </member>
        <member name="P:Quantum.Shape2D.CompoundShape2D.Count">
            <summary>
            The number of shapes in the compound buffer.
            </summary>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.CopyFrom(Quantum.Core.FrameBase,Quantum.Shape2D@)">
            <summary>
            Creates a copy of another compound <paramref name="shape"/>'s and any nested compound's buffers.
            The resultant shapes will not share data.
            </summary>
            <remarks>Any existing persistent compounds in this shape's hierarchy are disposed before copying.</remarks>
            <param name="f">The current frame being simulated.</param>
            <param name="shape">The compound shape that will be copied from.</param>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.AddShape(Quantum.Core.FrameBase,Quantum.Shape2D@,System.Boolean)">
            <summary>
            Adds the <paramref name="shape"/> to the compound buffer.
            </summary>
            <remarks>Trying to add a compound shape that holds a buffer already reference in this shape's hierarchy will throw an error in debug mode.</remarks>
            <param name="f">The frame currently being simulated.</param>
            <param name="shape">The shape being added to the compound.</param>
            <param name="updateCompoundMeta">If the compound meta data (e.g. broad radius and centroid) should be automatically updated.</param>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.RemoveShapes(Quantum.Core.FrameBase,System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Removes all shapes in a compound that have a <see cref="F:Quantum.Shape2D.UserTag"/> field matching the specified <paramref name="userTag"/>.
            </summary>
            <param name="f">The frame currently being simulated.</param>
            <param name="userTag">
            A tag that specifies a shape or group of shapes.
            Any shape in a compound that has a matching <see cref="F:Quantum.Shape2D.UserTag"/> field will be removed.
            If none is specified, all shapes are removed.
            </param>
            <param name="resetCompoundMeta">If the compound meta data (e.g. broad radius, centroid) should be automatically reset if any shapes are removed.</param>
            <param name="removeFromNested">If shapes should also be removed from any compound shape nested inside this.</param>
            <returns>True if at least one shape has been removed by this method.</returns>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.GetShapes(Quantum.Core.FrameBase,Quantum.Shape2D*@,System.Int32@)">
            <summary>
            Gets a pointer to the buffer of shapes added to this compound.
            </summary>
            <param name="f">The frame currently being simulated.</param>
            <param name="shapesBuffer">A pointer to the buffer of shapes added to this compound. Null if the compound doesn't have shapes.</param>
            <param name="count">The number of shapes in the <paramref name="shapesBuffer"/>.</param>
            <returns>True if the buffer has at least one shape</returns>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.ResetCompoundMeta(Quantum.Core.FrameBase)">
            <summary>
            Recomputes the compound shape broad radius, centroid and area sum (the later is used internally).
            </summary>
            <param name="f">The frame currently being simulated.</param>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.FreePersistent(Quantum.Core.FrameBase,System.Boolean)">
            <summary>
            Dispose any persistently allocated memory for this compound shape.
            </summary>
            <param name="f">The frame currently being simulated.</param>
            <param name="freeNestedPersistent">If nested compound shapes should also have persistent buffers disposed.</param>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.AssertExistingReference(Quantum.Core.FrameBase,Quantum.Ptr)">
            <summary>
            Returns true if this compound shape doesn't already reference the <paramref name="ptr"/> in it's hierarchy. 
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.UserTag">
            <summary>
            Set a number tag to identify a shape.
            </summary>
        </member>
        <member name="M:Quantum.Shape2D.GetLocalSupport(Quantum.Core.FrameBase,Photon.Deterministic.FPVector2,System.Boolean)">
            <summary>
            Computes a point on the shape which has the highest dot product in a given direction (<paramref name="localDir"/>),
            both in the local space of the shape.
            </summary>
            <param name="f">Current frame.</param>
            <param name="localDir">The direction, in local space, in which to compute the support point.</param>
            <param name="skipNormalize">If the provided direction is already normalized.</param>
            <returns>A point, in the local space of the shape, which has the highest dot product in the given direction.</returns>
        </member>
        <member name="T:Quantum.TriggerInfo2D">
            <summary>
            Info about a collision between a trigger and a non-trigger 2D physics colliders.
            </summary>
            <remarks>The info is taken from the perspective of the entity that has subscribed to the callback with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
            <remarks>No collision is checked between two kinematic colliders that are both trigger or both non-trigger.</remarks>
            <remarks>No detailed collision data (ContactPoint, ContactNormal and Penetration) is computed for trigger collisions. Use shape queries with the appropriate query options selected as an option.</remarks>
            <remarks>See <see cref="T:Quantum.TriggerInfo3D"/> for 3D trigger collisions and <see cref="T:Quantum.CollisionInfo2D"/> for 2D non-trigger collisions.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="P:Quantum.TriggerInfo2D.IsStatic">
            <summary>
            If the <see cref="P:Quantum.TriggerInfo2D.Entity"/> is touching a static trigger collider.
            If so, <see cref="P:Quantum.TriggerInfo2D.Other"/> has an <see cref="P:Quantum.EntityRef.None"/> value and the static collider data can be accessed through <see cref="P:Quantum.TriggerInfo2D.StaticData"/>.
            </summary>
            <code>
            if (info.IsStatic) {
              var otherStaticData = info.StaticData;
            } else {
              var otherEntity = info.Other;
            }
            </code>
        </member>
        <member name="P:Quantum.TriggerInfo2D.Entity">
            <summary>
            The main entity involved in the collision.
            </summary>
            <remarks>The info is taken from the perspective of this entity, which has subscribed to the callback with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
        </member>
        <member name="P:Quantum.TriggerInfo2D.EntityShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape2D.UserTag"/> of the entity's shape involved in the collision.
            </summary>
        </member>
        <member name="P:Quantum.TriggerInfo2D.Other">
            <summary>
            The other entity involved in the collision if the <see cref="P:Quantum.TriggerInfo2D.Entity"/> is NOT colliding with a static (check <see cref="P:Quantum.TriggerInfo2D.IsStatic"/>).
            </summary>
            <remarks>If the <see cref="P:Quantum.TriggerInfo2D.Entity"/> is colliding with a static, Other has <see cref="P:Quantum.EntityRef.None"/> value.</remarks>
        </member>
        <member name="P:Quantum.TriggerInfo2D.OtherShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape2D.UserTag"/> of the other entity's shape involved in the collision.
            Returns default value if the this is a static collision.
            </summary>
        </member>
        <member name="P:Quantum.TriggerInfo2D.StaticData">
            <summary>
            The <see cref="T:Quantum.StaticColliderData"/> of the static collider if the <see cref="P:Quantum.TriggerInfo2D.Entity"/> is colliding with a static (check <see cref="P:Quantum.TriggerInfo2D.IsStatic"/>).
            </summary>
        </member>
        <member name="T:Quantum.CharacterController3DMovement">
            <summary>
            Result of a 3D KCC raw movement query.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.Type">
            <summary>
            Recommended type of movement based on found collisions.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.NearestNormal">
            <summary>
            Surface normal of the nearest collision.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.AvgNormal">
            <summary>
            Average normal of all collisions.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.GroundNormal">
            <summary>
            Surface normal of the closest collision that qualifies as ground, if any.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.Tangent">
            <summary>
            Surface tangent (recommended movement direction) in case there's a desired direction passed.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.SlopeTangent">
            <summary>
            Surface tangent (recommended movement direction) in case of a slope (based on gravity).
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.Correction">
            <summary>
            Full correction vector to move out of collisions.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.Penetration">
            <summary>
            Magnitude of the penetration over the nearest normal.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.Grounded">
            <summary>
            True if at least one collision (not necessarily closest) qualifies as ground.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.Contacts">
            <summary>
            Total number of collisions found in this execution of the movement query.
            </summary>
        </member>
        <member name="T:Quantum.CharacterController3D">
            <summary>
            
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="P:Quantum.CharacterController3D.Jumped">
            <summary>
            If the character jumped this frame. See <see cref="M:Quantum.CharacterController3D.Jump(Quantum.Core.FrameBase,System.Boolean,System.Nullable{Photon.Deterministic.FP})"/>.
            <remarks>This state is consumed in the default steering method <see cref="M:Quantum.CharacterController3D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>.</remarks>
            </summary>
        </member>
        <member name="P:Quantum.CharacterController3D.BroadPhaseQueryIndex">
            <summary>
            The index of the Broad-Phase Query added by calling <see cref="M:Quantum.CharacterController3D.AddBroadPhaseQuery(Quantum.Core.FrameBase,Quantum.EntityRef,System.Nullable{System.Int32})"/>, -1 if no query has been added.
            This index will be used on the next time Move or ComputeRawMovement is called, to retrieve the resolved query results, and is automatically reset when that happens.
            Set this value to -1 in order to not use the BP Query result in the KCC movement. In this case a regular query will be performed, as by default.
            </summary>
        </member>
        <member name="M:Quantum.CharacterController3D.Init(Quantum.Core.FrameBase,Quantum.CharacterController3DConfig)">
            <summary>
            Initializes the 3D character controller component.
            <remarks>This method is not thread-safe. Use the thread-safe overload if calling from a threaded context.</remarks>
            </summary>
            <remarks>Can be used to reset the kcc config.</remarks>
            <param name="frame">The frame object.</param>
            <param name="config">The KCC <see cref="T:Quantum.CharacterController3DConfig"/> asset. If none is provided, the default asset is used.</param>
        </member>
        <member name="M:Quantum.CharacterController3D.Jump(Quantum.Core.FrameBase,System.Boolean,System.Nullable{Photon.Deterministic.FP})">
            <summary>
            Applies a vertical impulse to the KCC velocity.
            <remarks>This method is not thread-safe. Use the thread-safe overload if calling from a threaded context.</remarks>
            </summary>
            <remarks>No steering is performed at this stage. To actually move the character, use <see cref="M:Quantum.CharacterController3D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>.</remarks>
            <param name="frame">The frame object.</param>
            <param name="ignoreGrounded">If the <see cref="P:Quantum.CharacterController3D.Grounded"/> state of the KCC should be ignored.</param>
            <param name="impulse">The amount of impulse applied to the KCC. If none is provided, the <see cref="F:Quantum.CharacterController3DConfig.BaseJumpImpulse"/> of the KCC config is used.</param>
        </member>
        <member name="M:Quantum.CharacterController3D.AddBroadPhaseQuery(Quantum.Core.FrameBase,Quantum.EntityRef,System.Nullable{System.Int32})">
            <summary>
            Adds a Broad-phase query to the 3D Physics scene, according to the KCC config settings, and store the query index in <see cref="P:Quantum.CharacterController3D.BroadPhaseQueryIndex"/>.
            This index will be used on the next time Move or ComputeRawMovement is called, to retrieve the resolved query results and perform the KCC logic.
            </summary>
            <remarks>
            The added BP-Query must be retrieve on the same frame. To cancel the addition of a BP-Query and perform a regular one when moving the KCC, set <see cref="P:Quantum.CharacterController3D.BroadPhaseQueryIndex"/> to -1. 
            </remarks>
            <param name="frame">The current frame object.</param>
            <param name="entity">The entity that represents the character. It must have a <see cref="T:Quantum.Transform3D"/> component, which will be used to compute the query position.</param>
            <param name="layerMask">A mask that specifies which layers should be considered by the query. If null (default), the layer maks defined in the KCC config will be used.</param>
            <returns>The index of the added query.</returns>
        </member>
        <member name="M:Quantum.CharacterController3D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})">
            <summary>
            Queries the 3D physics scene with <see cref="M:Quantum.CharacterController3D.ComputeRawMovement(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Transform3D*,Quantum.CharacterController3D*,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean})"/>, computes a default steering in the desired <paramref name="direction"/> and moves the <paramref name="entity"/>.
            <remarks>This method is not thread-safe. Use the thread-safe overload if calling from a threaded context.</remarks>
            </summary>
            <remarks>The entity must have a Transform3D component.</remarks>
            <param name="frame">The frame in which the entity is being moved.</param>
            <param name="entity">The entity that represents the character. Any collider attached by this entity is ignored in the raw movement computation.</param>
            <param name="direction">The intended movement direction.</param>
            <param name="callback">An object that can receive the KCC callbacks. If calling from a system that implements the interface, you can use the "this" keyword.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against in the raw movement computation.
            If null is passed, the layer maks defined in the KCC config will be used. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="useManifoldNormal">
            If the hit manifold normal should be used when computing the raw movement.
            If false, the normal is computed from the query position and the contact point.
            If no value is provided, the <see cref="F:Quantum.CharacterController3DConfig.UseManifoldNormal"/> of the KCC config is used.
            </param>
            <param name="deltaTime">The delta timed used to integrate the kcc velocity. If no value is provided, the <paramref name="frame"/> delta time is used.</param>
        </member>
        <member name="M:Quantum.CharacterController3D.ComputeRawMovement(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Transform3D*,Quantum.CharacterController3D*,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean})">
            <summary>
            Queries the 3D physics scene in the <paramref name="transform"/> position, using the <paramref name="kcc"/> config, and computes movement data.
            The movement data can be used to apply a custom steering to the character based on its surrounding environment.
            For using the default steering, use <see cref="M:Quantum.CharacterController3D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>.
            </summary>
            <param name="frame">The frame in which the physics scene is being queried.</param>
            <param name="entity">The entity that represents the character. Any collider attached by this entity is ignored in the raw movement computation.</param>
            <param name="transform">A pointer to a Transform3D component that has the position where the scene will be queried at, usually being the <paramref name="entity"/> transform.</param>
            <param name="kcc">A pointer to a CharacterController3D component that has the config used by the query, usually being the <paramref name="entity"/> kcc component.</param>
            <param name="direction">The intended movement direction.</param>
            <param name="callback">An object that can receive the KCC callbacks.
            <remarks>If calling from a system that implements the interface, you can use the "this" keyword.</remarks>
            </param>
            <param name="layerMask">A mask that specifies which layers will be checked against in the raw movement computation.
            If null is passed, the layer maks defined in the KCC config will be used. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="useManifoldNormal">
            If the hit manifold normal should be used when computing the raw movement.
            If false, the normal is computed from the query position and the contact point.
            If no value is provided, the <see cref="F:Quantum.CharacterController3DConfig.UseManifoldNormal"/> of the KCC config is used.
            </param>
            <returns>A <see cref="T:Quantum.CharacterController3DMovement"/> struct with raw movement data that can be used to compute a custom steering.</returns>
        </member>
        <member name="F:Quantum.PhysicsBody3D.ConfigFlags.Default">
            <summary>IsAllowedToSleep | IsAwakenedByForces | ResetInertiaOnAdded | ResetCenterOfMassOnAdded</summary>
        </member>
        <member name="M:Quantum.PhysicsBody3D.ResetInertia(Quantum.Core.FrameBase,Quantum.EntityRef)">
            <summary>
            Resets the inertia on this physics body component based on its mass and the shape of a
            <see cref="T:Quantum.PhysicsCollider3D"/> component on the <paramref name="entity"/>.
            <remarks>
            This is called automatically when a <see cref="T:Quantum.PhysicsBody3D"/> component is added to an entity, unless the body <see cref="F:Quantum.PhysicsBody3D.ConfigFlags.ResetInertiaOnAdded"/> flag is not set.
            The body's center of mass affects the computation of the inertia, so consider calling
            <see cref="M:Quantum.PhysicsBody3D.ResetCenterOfMass(Quantum.Core.FrameBase,Quantum.EntityRef)"/> before resetting the inertia, specially if the collider shape has changed.
            More info on the online docs <a href="https://doc.photonengine.com/en-us/quantum/v2/manual/physics/collider-body#changing_the_shape_at_runtime">here</a>.
            </remarks>
            </summary>
            <param name="frame">Current frame instance in use.</param>
            <param name="entity">The entity from which the collider shape will be retrieved, necessary for computing the inertia.</param>
        </member>
        <member name="M:Quantum.PhysicsBody3D.ResetCenterOfMass(Quantum.Core.FrameBase,Quantum.EntityRef)">
            <summary>
            Resets the <see cref="P:Quantum.PhysicsBody3D.CenterOfMass"/> of physics body component to the the shape <see cref="F:Quantum.Shape3D.Centroid">centroid</see>
            of a <see cref="T:Quantum.PhysicsCollider3D"/> component attached to the <paramref name="entity"/>.
            <remarks>
            This is called automatically when a <see cref="T:Quantum.PhysicsBody3D"/> component is added to an entity,
            unless the body <see cref="F:Quantum.PhysicsBody3D.ConfigFlags.ResetCenterOfMassOnAdded"/> flag is not set.
            When changing the collider shape in runtime, consider resetting the center of mass and inertia of the attached physics body,
            in this order. More info on the online docs <a href="https://doc.photonengine.com/en-us/quantum/v2/manual/physics/collider-body#changing_the_shape_at_runtime">here</a>.
            </remarks>
            </summary>
            <param name="f">Current frame instance in use.</param>
            <param name="entity">The entity from which the collider component and shape will be retrieved.</param>
        </member>
        <member name="M:Quantum.PhysicsBody3D.GetPointVelocity(Photon.Deterministic.FPVector3,Quantum.Transform3D*)">
            <summary>
            Computes the velocity of the physics body at a given <paramref name="point"/> defined in world space.
            </summary>
            <param name="point">The point where the velocity will be computed at, in world space.</param>
            <param name="bodyTransform">The transform component of the entity to which this physics body belongs.</param>
            <returns>A 3D vector representing the computed velocity, also in world space.</returns>
        </member>
        <member name="M:Quantum.PhysicsBody3D.GetRelativePointVelocity(Photon.Deterministic.FPVector3,Quantum.Transform3D*)">
            <summary>
            Computes the velocity of the physics body at a given <paramref name="point"/> defined on its local space.
            </summary>
            <param name="point">The point where the velocity will be computed at, in local space.</param>
            <param name="bodyTransform">The transform component of the entity to which this physics body belongs.</param>
            <returns>A 3D vector representing the computed velocity, in world space.</returns>
        </member>
        <member name="M:Quantum.PhysicsBody3D.Sleep">
            <summary>
            Puts an enabled physics body into a sleeping state.
            <remarks>
            If set during a physics collision callback, the body might be awakened by the solver if the collision is not ignored.  
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCollider3D.Enabled">
            <summary>
            If this component should be considered by the Physics Engine.
            <remarks>
            Disabling a collider has immediate effect: queries will not find it, nor will collisions be solved nor callbacks called.
            Re-enabling, on the other hand, is deferred to the next Physics Update.
            </remarks>
            </summary>
        </member>
        <member name="T:Quantum.ExitInfo3D">
            <summary>
            Info about two entities that were colliding in the 3D Physics.
            </summary>
            <remarks>The info is taken from the perspective of the entity that has subscribed to the callback with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
            <remarks>See <see cref="T:Quantum.CollisionInfo3D"/> for 3D collisions and <see cref="T:Quantum.TriggerInfo3D"/> for 3D trigger collisions.</remarks>
            \ingroup Physics3dApi
        </member>
        <member name="P:Quantum.ExitInfo3D.Entity">
            <summary>
            The main entity that was involved in the collision.
            </summary>
            <remarks>The info is taken from the perspective of this entity, which has subscribed to the callback with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
        </member>
        <member name="P:Quantum.ExitInfo3D.Other">
            <summary>
            The other entity that was involved in the collision if the <see cref="P:Quantum.ExitInfo3D.Entity"/> was NOT colliding with a static (check <see cref="P:Quantum.ExitInfo3D.IsStatic"/>).
            </summary>
            <remarks>If the <see cref="P:Quantum.ExitInfo3D.Entity"/> was colliding with a static, Other has <see cref="P:Quantum.EntityRef.None"/> value.</remarks>
        </member>
        <member name="P:Quantum.ExitInfo3D.IsStatic">
            <summary>
            If the <see cref="P:Quantum.ExitInfo3D.Entity"/> was touching a static collider.
            If so, <see cref="P:Quantum.ExitInfo3D.Other"/> has an <see cref="P:Quantum.EntityRef.None"/> value and the static collider data can be accessed through <see cref="P:Quantum.ExitInfo3D.StaticData"/>.
            </summary>
            <code>
            if (info.IsStatic) {
              var otherStaticData = info.StaticData;
            } else {
              var otherEntity = info.Other;
            }
            </code>
        </member>
        <member name="P:Quantum.ExitInfo3D.StaticData">
            <summary>
            The <see cref="T:Quantum.StaticColliderData"/> of the static collider if the <see cref="P:Quantum.ExitInfo3D.Entity"/> was colliding with a static (check <see cref="P:Quantum.ExitInfo3D.IsStatic"/>).
            </summary>
        </member>
        <member name="T:Quantum.CollisionInfo3D">
            <summary>
            Info about a collision between two 3D physics colliders.
            </summary>
            <remarks>The info is taken from the perspective of the entity that has subscribed to the callback with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
            <remarks>See <see cref="T:Quantum.CollisionInfo2D"/> for 2D collisions and <see cref="T:Quantum.TriggerInfo3D"/> for 3D trigger collisions.</remarks>
            \ingroup Physics3dApi
        </member>
        <member name="P:Quantum.CollisionInfo3D.ContactPointIterator3D.Count">
            <summary>
            The number of contact points on this collision.
            <remarks>
            If the entity is colliding with a mesh, this is the sum of all contact points with the triangles of the mesh.
            To access each specific triangle collision, check <see cref="F:Quantum.CollisionInfo3D.MeshTriangleCollisions"/>.
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.ContactPointIterator3D.Average">
            <summary>
            The average contact point on this collision.
            <remarks>
            If the entity is colliding with a mesh, this is the average of all contact points with the triangles of the mesh.
            To access each specific triangle collision, check <see cref="F:Quantum.CollisionInfo3D.MeshTriangleCollisions"/>.
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.ContactPointIterator3D.First">
            <summary>
            The first contact point computed on this collision.
            <remarks>Contact points are computed in NO particular order.</remarks>
            <remarks>If the entity is colliding with a mesh, this is the first contact point with the first triangle.</remarks>
            </summary>
        </member>
        <member name="M:Quantum.CollisionInfo3D.ContactPointIterator3D.Next(Photon.Deterministic.FPVector3@)">
            <summary>
            Iterates through the contact points of a collision.
            <remarks>If the entity is colliding with a mesh, this will iterate through all contact points in all colliding triangles.</remarks>
            </summary>
            <param name="contactPoint">The current contact point. Default if the iteration is over.</param>
            <returns>True if there is still a <paramref name="contactPoint"/>.</returns>
            <code>
            while(info.ContactPoints.Next(out var cp) {
              Draw.Sphere(cp, FP._0_10);
            }
            </code>
        </member>
        <member name="M:Quantum.CollisionInfo3D.ContactPointIterator3D.Next(Photon.Deterministic.FPVector3@,Photon.Deterministic.FPVector3@)">
            <summary>
            Iterates through the contact points of a collision, also accessing the contact normal.
            <remarks>If the entity is colliding with a mesh, this will iterate through all contact points and normals in all colliding triangles.</remarks>
            </summary>
            <param name="contactPoint">The current contact point. Default if the iteration is over.</param>
            <param name="contactNormal">The contact normal. Default if the iteration is over.</param>
            <returns>True if there is still a <paramref name="contactPoint"/> and <paramref name="contactNormal"/>.</returns>
            <code>
            while(info.ContactPoints.Next(out var contactPoint, out var contactNormal) {
               Draw.Sphere(contactPoint, FP._0_10);
               Draw.Ray(contactPoint, contactNormal);
            }
            </code>
        </member>
        <member name="M:Quantum.CollisionInfo3D.ContactPointIterator3D.ResetIterator">
            <summary>
            Resets the iterator.
            </summary>
        </member>
        <member name="M:Quantum.CollisionInfo3D.TriangleCollisionIterator.Next(Quantum.CollisionInfo3D.TriangleCollisionInfo@)">
            <summary>
            Iterates through the triangle collisions with a mesh.
            </summary>
            <param name="current">Information about the current triangle collision on the iteration. Default if the iteration is over.</param>
            <returns>True if there is still a <paramref name="current"/> triangle collision info.</returns>
            <code>
            while(info.MeshTriangleCollisions.Next(out var triCollision) {
              Draw.Ray(triCollision.Triangle->Center, triCollision.ContactNormal * triCollision.Penetration);
            }
            </code>
        </member>
        <member name="M:Quantum.CollisionInfo3D.TriangleCollisionIterator.ResetIterator">
            <summary>
            Resets the iterator.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.TriangleCollisionIterator.AverageNormal">
            <summary>
            The average contact normal of all the collisions with the triangles of the mesh.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.TriangleCollisionIterator.AveragePenetration">
            <summary>
            The average penetration of all the collisions with the triangles of the mesh.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.TriangleCollisionInfo.IgnoreCollision">
            <summary>
            If this triangle collision should be ignored by the physics engine.
            </summary>
        </member>
        <member name="F:Quantum.CollisionInfo3D.TriangleCollisionInfo.ContactPoints">
            <summary>
            Data about the contact points of the triangle collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.TriangleCollisionInfo.Triangle">
            <summary>
            The triangle of the mesh that the entity is colliding with.
            <remarks>This is not a copy but a pointer to the actual triangle data in the scene mesh, do NOT change it.</remarks>
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.TriangleCollisionInfo.ContactNormal">
            <summary>
            The contact normal, from the <see cref="P:Quantum.CollisionInfo3D.Entity"/> perspective.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.TriangleCollisionInfo.Penetration">
            <summary>
            The collision penetration in the <see cref="P:Quantum.CollisionInfo3D.TriangleCollisionInfo.ContactNormal"/> direction.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.IgnoreCollision">
            <summary>
            If the collision should be ignored by the physics engine.
            </summary>
        </member>
        <member name="F:Quantum.CollisionInfo3D.ContactPoints">
            <summary>
            Data about the contact points of the collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.ContactNormal">
            <summary>
            The contact normal, from the <see cref="P:Quantum.CollisionInfo3D.Entity"/> perspective.
            <remarks>In a mesh collision (<see cref="P:Quantum.CollisionInfo3D.IsMeshCollision"/> true), this is the average normal of all triangle collisions in this mesh.</remarks>
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.Penetration">
            <summary>
            The collision penetration in the <see cref="P:Quantum.CollisionInfo3D.ContactNormal"/> direction.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.IsStatic">
            <summary>
            If the <see cref="P:Quantum.CollisionInfo3D.Entity"/> is touching a static collider.
            If so, <see cref="P:Quantum.CollisionInfo3D.Other"/> has an <see cref="P:Quantum.EntityRef.None"/> value and the static collider data can be accessed through <see cref="P:Quantum.CollisionInfo3D.StaticData"/>.
            </summary>
            <code>
            if (info.IsStatic) {
              var otherStaticData = info.StaticData;
            } else {
              var otherEntity = info.Other;
            }
            </code>
        </member>
        <member name="P:Quantum.CollisionInfo3D.IsMeshCollision">
            <summary>
            If the <see cref="P:Quantum.CollisionInfo3D.Entity"/> is colliding with a static mesh.
            More data about the mesh collision, including individual triangle collisions, can be accessed in <see cref="F:Quantum.CollisionInfo3D.MeshTriangleCollisions"/>.
            </summary>
            <code>
            if (info.IsMeshCollision) {
              while(info.MeshTriangleCollisions.Next(out var triCollision)) {
                Draw.Ray(triCollision.Triangle->Center, triCollision.ContactNormal);
              }
            }
            </code>
        </member>
        <member name="F:Quantum.CollisionInfo3D.MeshTriangleCollisions">
            <summary>
            Additional data regarding a mesh collision, including all the individual triangles.
            To know if this is a mesh collision, check <see cref="P:Quantum.CollisionInfo3D.IsMeshCollision"/>.
            </summary>
            <code>
            if (info.IsMeshCollision) {
              Log.Info($"Average normal: {info.MeshTriangleCollisions.AverageNormal}");
              while(info.MeshTriangleCollisions.Next(out var triCollision)) {
                Draw.Ray(triCollision.Triangle->Center, triCollision.ContactNormal);
              }
            }
            </code>
        </member>
        <member name="P:Quantum.CollisionInfo3D.Entity">
            <summary>
            The main entity involved in the collision.
            </summary>
            <remarks>The info is taken from the perspective of this entity, which has subscribed to the callback with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
        </member>
        <member name="P:Quantum.CollisionInfo3D.EntityShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape3D.UserTag"/> of the entity's shape involved in the collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.Other">
            <summary>
            The other entity involved in the collision if the <see cref="P:Quantum.CollisionInfo3D.Entity"/> is NOT colliding with a static (check <see cref="P:Quantum.CollisionInfo3D.IsStatic"/>).
            <remarks>If the <see cref="P:Quantum.CollisionInfo3D.Entity"/> is colliding with a static, Other has <see cref="P:Quantum.EntityRef.None"/> value.</remarks>
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.OtherShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape3D.UserTag"/> of the other entity's shape involved in the collision.
            Returns default value if the this is a static collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.StaticData">
            <summary>
            The <see cref="T:Quantum.StaticColliderData"/> if the <see cref="P:Quantum.CollisionInfo3D.Entity"/> is colliding with a static (check <see cref="P:Quantum.CollisionInfo3D.IsStatic"/>).
            </summary>
        </member>
        <member name="T:Quantum.Shape3D">
            <summary>
            Defines a 3D shape with <see cref="P:Quantum.Shape3D.Type"/> and data disposed in a union-like structure.
            All shapes have a <see cref="F:Quantum.Shape3D.UserTag"/>, <see cref="F:Quantum.Shape3D.BroadRadius"/> and <see cref="F:Quantum.Shape3D.Centroid"/>.
            All non-compound shapes have a <see cref="F:Quantum.Shape3D.LocalTransform"/> and their <see cref="F:Quantum.Shape3D.Centroid"/> always match their local transform position.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="T:Quantum.Shape3D.CompoundShape3D">
            <summary>
            A 3D shape type that can reference a group of other 3D shapes (including other compounds, but not Mesh and Terrain shapes).
            Compound shape overlaps and physics colliders with compound shapes are supported.
            </summary>
        </member>
        <member name="P:Quantum.Shape3D.CompoundShape3D.IsPersistent">
            <summary>
            If the buffer of shapes is persistently allocated.
            </summary>
            <remarks>Persistently allocated memory is not disposed automatically. Call <see cref="M:Quantum.Shape3D.CompoundShape3D.FreePersistent(Quantum.Core.FrameBase,System.Boolean)"/> when done using a persistent compound.</remarks>
        </member>
        <member name="P:Quantum.Shape3D.CompoundShape3D.Count">
            <summary>
            The number of shapes in the compound buffer.
            </summary>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.CopyFrom(Quantum.Core.FrameBase,Quantum.Shape3D@)">
            <summary>
            Creates a copy of another compound <paramref name="shape"/>'s and any nested compound's buffers.
            The resultant shapes will not share data.
            </summary>
            <remarks>Any existing persistent compounds in this shape's hierarchy are disposed before copying.</remarks>
            <param name="f">The current frame being simulated.</param>
            <param name="shape">The compound shape that will be copied from.</param>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.AddShape(Quantum.Core.FrameBase,Quantum.Shape3D@,System.Boolean)">
            <summary>
            Adds the <paramref name="shape"/> to the compound buffer.
            </summary>
            <remarks>Trying to add a compound shape that holds a buffer already reference in this shape's hierarchy will throw an error in debug mode.</remarks>
            <remarks>Mesh and Terrain shapes cannot be added to a compound shape.</remarks>
            <param name="f">The frame currently being simulated.</param>
            <param name="shape">The shape being added to the compound.</param>
            <param name="updateCompoundMeta">If the compound meta data (e.g. broad radius and centroid) should be automatically updated.</param>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.RemoveShapes(Quantum.Core.FrameBase,System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Removes all shapes in a compound that have a <see cref="F:Quantum.Shape3D.UserTag"/> field matching the specified <paramref name="userTag"/>.
            </summary>
            <param name="f">The frame currently being simulated.</param>
            <param name="userTag">
            A tag that specifies a shape or group of shapes.
            Any shape in a compound that has a matching <see cref="F:Quantum.Shape3D.UserTag"/> field will be removed.
            If none is specified, all shapes are removed.
            </param>
            <param name="resetCompoundMeta">If the compound meta data (e.g. broad radius, centroid) should be automatically reset if any shapes are removed.</param>
            <param name="removeFromNested">If shapes should also be removed from any compound shape nested inside this.</param>
            <returns>True if at least one shape has been removed by this method.</returns>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.GetShapes(Quantum.Core.FrameBase,Quantum.Shape3D*@,System.Int32@)">
            <summary>
            Gets a pointer to the buffer of shapes added to this compound.
            </summary>
            <param name="f">The frame currently being simulated.</param>
            <param name="shapesBuffer">A pointer to the buffer of shapes added to this compound. Null if the compound doesn't have shapes.</param>
            <param name="count">The number of shapes in the <paramref name="shapesBuffer"/>.</param>
            <returns>True if the buffer has at least one shape</returns>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.ResetCompoundMeta(Quantum.Core.FrameBase)">
            <summary>
            Recomputes the compound shape broad radius, centroid and volume sum (the later is used internally).
            </summary>
            <param name="f">The frame currently being simulated.</param>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.FreePersistent(Quantum.Core.FrameBase,System.Boolean)">
            <summary>
            Dispose any persistently allocated memory for this compound shape.
            </summary>
            <param name="f">The frame currently being simulated.</param>
            <param name="freeNestedPersistent">If nested compound shapes should also have persistent buffers disposed.</param>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.AssertExistingReference(Quantum.Core.FrameBase,Quantum.Ptr)">
            <summary>
            Returns true if this compound shape doesn't already reference the <paramref name="ptr"/> in it's hierarchy. 
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.UserTag">
            <summary>
            Set a number tag to identify a shape.
            </summary>
        </member>
        <member name="M:Quantum.Shape3D.GetLocalSupport(Quantum.Core.FrameBase,Photon.Deterministic.FPVector3,System.Boolean)">
            <summary>
            Computes a point on the shape which has the highest dot product in a given direction (<paramref name="localDir"/>),
            both in the local space of the shape.
            </summary>
            <param name="f">Current frame.</param>
            <param name="localDir">The direction, in local space, in which to compute the support point.</param>
            <param name="skipNormalize">If the provided direction is already normalized.</param>
            <returns>A point, in the local space of the shape, which has the highest dot product in the given direction.</returns>
        </member>
        <member name="T:Quantum.TriggerInfo3D">
            <summary>
            Info about a collision between a trigger and a non-trigger 3D physics colliders.
            </summary>
            <remarks>The info is taken from the perspective of the entity that has subscribed to the callback with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
            <remarks>No collision is checked between two kinematic colliders that are both trigger or both non-trigger.</remarks>
            <remarks>No detailed collision data (ContactPoint, ContactNormal and Penetration) is computed for trigger collisions. Use shape queries with the appropriate query options selected as an option.</remarks>
            <remarks>See <see cref="T:Quantum.TriggerInfo2D"/> for 2D trigger collisions and <see cref="T:Quantum.CollisionInfo3D"/> for 3D non-trigger collisions.</remarks>
            \ingroup Physics3dApi
        </member>
        <member name="P:Quantum.TriggerInfo3D.IsStatic">
            <summary>
            If the <see cref="P:Quantum.TriggerInfo3D.Entity"/> is touching a static trigger collider.
            If so, <see cref="P:Quantum.TriggerInfo3D.Other"/> has an <see cref="P:Quantum.EntityRef.None"/> value and the static collider data can be accessed through <see cref="P:Quantum.TriggerInfo3D.StaticData"/>.
            </summary>
            <code>
            if (info.IsStatic) {
              var otherStaticData = info.StaticData;
            } else {
              var otherEntity = info.Other;
            }
            </code>
        </member>
        <member name="P:Quantum.TriggerInfo3D.Entity">
            <summary>
            The main entity involved in the collision.
            </summary>
            <remarks>The info is taken from the perspective of this entity, which has subscribed to the callback with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
        </member>
        <member name="P:Quantum.TriggerInfo3D.EntityShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape3D.UserTag"/> of the entity's shape involved in the collision.
            </summary>
        </member>
        <member name="P:Quantum.TriggerInfo3D.Other">
            <summary>
            The other entity involved in the collision if the <see cref="P:Quantum.TriggerInfo3D.Entity"/> is NOT colliding with a static (check <see cref="P:Quantum.TriggerInfo3D.IsStatic"/>).
            </summary>
            <remarks>If the <see cref="P:Quantum.TriggerInfo3D.Entity"/> is colliding with a static, Other has <see cref="P:Quantum.EntityRef.None"/> value.</remarks>
        </member>
        <member name="P:Quantum.TriggerInfo3D.OtherShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape3D.UserTag"/> of the other entity's shape involved in the collision.
            Returns default value if the this is a static collision.
            </summary>
        </member>
        <member name="P:Quantum.TriggerInfo3D.StaticData">
            <summary>
            The <see cref="T:Quantum.StaticColliderData"/> of the static collider if the <see cref="P:Quantum.TriggerInfo3D.Entity"/> is colliding with a static (check <see cref="P:Quantum.TriggerInfo3D.IsStatic"/>).
            </summary>
        </member>
        <member name="T:Quantum.CallbackFlags">
            <summary>
            Represents which collision callbacks will be called for an entity.
            <remarks>By default, no callbacks are called unless at least one of the entities involved in a collision have the respective flag set.</remarks>
            <remarks>The callbacks are called for every entity involved in a collision that has the respective collision type flag set.</remarks>
            </summary>
            <remarks>No collision is checked between two kinematic colliders that are both trigger or both non-trigger.</remarks>
        </member>
        <member name="F:Quantum.CallbackFlags.None">
            <summary>
            Set None to stop receiving callbacks for an entity.
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnDynamicCollision">
            <summary>
            Called once per frame while two non-trigger colliders are touching.
            <remarks>Related signals: <see cref="!:ISignalOnCollision2D"/> and <see cref="!:ISignalOnCollision3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnDynamicCollisionEnter">
            <summary>
            Called once two non-trigger colliders start touching.
            <remarks>Related signals: <see cref="!:ISignalOnCollisionEnter2D"/> and <see cref="!:ISignalOnCollisionEnter3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnDynamicCollisionExit">
            <summary>
            Called once two non-trigger colliders stop touching.
            <remarks>Related signals: <see cref="!:ISignalOnCollisionExit2D"/> and <see cref="!:ISignalOnCollisionExit3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnStaticCollision">
            <summary>
            Called once per frame while a non-trigger collider is touching a non-trigger static collider.
            <remarks>Related signals: <see cref="!:ISignalOnCollision2D"/> and <see cref="!:ISignalOnCollision3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnStaticCollisionEnter">
            <summary>
            Called once a non-trigger collider start touching a non-trigger static collider.
            <remarks>Related signals: <see cref="!:ISignalOnCollisionEnter2D"/> and <see cref="!:ISignalOnCollisionEnter3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnStaticCollisionExit">
            <summary>
            Called once a non-trigger collider stop touching a non-trigger static collider.
            <remarks>Related signals: <see cref="!:ISignalOnCollisionExit2D"/> and <see cref="!:ISignalOnCollisionExit3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnDynamicTrigger">
            <summary>
            Called once per frame while a trigger collider is touching a non-trigger collider.
            <remarks>Related signals: <see cref="!:ISignalOnTrigger2D"/> and <see cref="!:ISignalOnTrigger3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnDynamicTriggerEnter">
            <summary>
            Called once a trigger collider start touching a non-trigger collider.
            <remarks>Related signals: <see cref="!:ISignalOnTriggerEnter2D"/> and <see cref="!:ISignalOnTriggerEnter3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnDynamicTriggerExit">
            <summary>
            Called once a trigger collider stop touching a non-trigger collider.
            <remarks>Related signals: <see cref="!:ISignalOnTriggerExit2D"/> and <see cref="!:ISignalOnTriggerExit3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnStaticTrigger">
            <summary>
            Called once per frame while a non-trigger collider is touching a trigger static collider.
            <remarks>Related signals: <see cref="!:ISignalOnTrigger2D"/> and <see cref="!:ISignalOnTrigger3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnStaticTriggerEnter">
            <summary>
            Called once a non-trigger collider start touching a trigger static collider.
            <remarks>Related signals: <see cref="!:ISignalOnTriggerEnter2D"/> and <see cref="!:ISignalOnTriggerEnter3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnStaticTriggerExit">
            <summary>
            Called once a non-trigger collider stop touching a trigger static collider.
            <remarks>Related signals: <see cref="!:ISignalOnTriggerExit2D"/> and <see cref="!:ISignalOnTriggerExit3D"/>.</remarks>
            </summary>
        </member>
        <member name="T:Quantum.Transform3D">
            <summary>
            The Transform3D is an entity component providing position and rotation for a 3D object.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.EulerAngles">
            <summary>
            Converts rotation to Euler angles triplet.
            </summary>
            <seealso cref="P:Photon.Deterministic.FPQuaternion.AsEuler"/>.
        </member>
        <member name="P:Quantum.Transform3D.LocalToWorldMatrix">
            <summary>
            Creates local to world transformation. <see cref="F:Quantum.Transform3D.Rotation"/> is expected to be normalized.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.WorldToLocalMatrix">
            <summary>
            Creates world to local transformation. <see cref="F:Quantum.Transform3D.Rotation"/> is expected to be normalized.
            </summary>
        </member>
        <member name="M:Quantum.Transform3D.InverseTransformDirection(Photon.Deterministic.FPVector3)">
            <summary>
            Transforms a direction from world space to local space. <see cref="F:Quantum.Transform3D.Rotation"/> is expected to be normalized.
            </summary>
        </member>
        <member name="M:Quantum.Transform3D.TransformDirection(Photon.Deterministic.FPVector3)">
            <summary>
            Transforms a direction from local space to world space. <see cref="F:Quantum.Transform3D.Rotation"/> is expected to be normalized.
            </summary>
        </member>
        <member name="M:Quantum.Transform3D.InverseTransformPoint(Photon.Deterministic.FPVector3)">
            <summary>
            Transforms a position from world space to local space. <see cref="F:Quantum.Transform3D.Rotation"/> is expected to be normalized.
            </summary>
        </member>
        <member name="M:Quantum.Transform3D.TransformPoint(Photon.Deterministic.FPVector3)">
            <summary>
            Transforms a position from local space to world space. <see cref="F:Quantum.Transform3D.Rotation"/> is expected to be normalized.
            </summary>
        </member>
        <member name="M:Quantum.Transform3D.LookAt(Photon.Deterministic.FPVector3,System.Nullable{Photon.Deterministic.FPVector3})">
            <summary>
            Rotates the transform so the forward vector points at <paramref name="position"/>. If <paramref name="up"/> is not set, will use <see cref="P:Photon.Deterministic.FPVector3.Up"/> instead.
            </summary>
            <param name="position"></param>
            <param name="up"></param>
        </member>
        <member name="M:Quantum.Transform3D.Rotate(Photon.Deterministic.FPVector3)">
            <summary>
            Applies a rotation of <paramref name="angles"/>.z degrees around the z-axis, <paramref name="angles"/>.x degrees around the x-axis, and <paramref name="angles"/>.y degrees around the y-axis (in that order).
            </summary>
        </member>
        <member name="M:Quantum.Transform3D.Rotate(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Applies a rotation of <paramref name="zAngle"/> degrees around the z-axis, <paramref name="xAngle"/> degrees around the x-axis, and <paramref name="yAngle"/> degrees around the y-axis (in that order).
            </summary>
            <param name="xAngle"></param>
            <param name="yAngle"></param>
            <param name="zAngle"></param>
        </member>
        <member name="M:Quantum.Transform3D.Rotate(Photon.Deterministic.FPVector3,Photon.Deterministic.FP)">
            <summary>
            Rotates the object around the given axis by the number of degrees defined by the given angle.
            </summary>
            <param name="axis"></param>
            <param name="angle"></param>
        </member>
        <member name="P:Quantum.Transform3D.Right">
            <summary>
            A vector pointing to local +X axis.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.Up">
            <summary>
            A vector pointing to local +Y axis.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.Forward">
            <summary>
            A vector pointing to local +Z axis.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.Left">
            <summary>
            A vector pointing to local -X axis.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.Down">
            <summary>
            A vector pointing to local -Y axis.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.Back">
            <summary>
            A vector pointing to local -Z axis.
            </summary>
        </member>
        <member name="M:Quantum.Layers.Init(System.String[],System.Int32[],System.Boolean)">
            <summary>
            Initialize Layers based on the provided <paramref name="layers"/> and <paramref name="defaultMatrix"/>.
            <remarks>Forcing initialization with <paramref name="forceInitUnsafe"/> is NOT thread-safe.</remarks>
            </summary>
        </member>
        <member name="T:Quantum.PlayerRef">
            <summary>
            Represents a Quantum player.
            </summary>
            <para>The PlayerRef, in contrast to the player index, is 1-based. The reason is that default(PlayerRef) will return a "null/invalid" player ref struct for convenience. There are automatic cast operators that can cast an int into a PlayerRef.</para>
            <example><code>
            default(PlayerRef), internally a 0, means NOBODY
            PlayerRef, internally 1, is the same as player index 0
            PlayerRef, internally 2, is the same as player index 1
            </code></example>
        </member>
        <member name="P:Quantum.PlayerRef.None">
            <summary>
            None player has index 0.
            </summary>
        </member>
        <member name="T:Quantum.Transform2D">
            <summary>
            The Transform2D is an entity component providing position and rotation a 2D object.
            </summary>
        </member>
        <member name="M:Quantum.Transform2D.TransformPoint(Photon.Deterministic.FPVector2)">
            <summary>
            Transforms a <paramref name="point"/> from local to world space.
            See also: <seealso cref="M:Quantum.Transform2D.InverseTransformPoint(Photon.Deterministic.FPVector2)"/>.
            </summary>
            <param name="point">A point in local space.</param>
            <returns>The transformed point in world space.</returns>
        </member>
        <member name="M:Quantum.Transform2D.InverseTransformPoint(Photon.Deterministic.FPVector2)">
            <summary>
            Transforms a <paramref name="point"/> from world to local space.
            See also: <seealso cref="M:Quantum.Transform2D.TransformPoint(Photon.Deterministic.FPVector2)"/>.
            </summary>
            <param name="point">A point in world space.</param>
            <returns>The transformed point in local space.</returns>
        </member>
        <member name="M:Quantum.Transform2D.TransformDirection(Photon.Deterministic.FPVector2)">
            <summary>
            Transforms a <paramref name="direction"/> from local to world space.
            See also: <seealso cref="M:Quantum.Transform2D.InverseTransformDirection(Photon.Deterministic.FPVector2)"/>.
            </summary>
            <param name="direction">A direction in local space.</param>
            <returns>The transformed direction in world space.</returns>
        </member>
        <member name="M:Quantum.Transform2D.InverseTransformDirection(Photon.Deterministic.FPVector2)">
            <summary>
            Transforms a <paramref name="direction"/> from world to local space.
            See also: <seealso cref="M:Quantum.Transform2D.TransformDirection(Photon.Deterministic.FPVector2)"/>.
            </summary>
            <param name="direction">A direction in world space.</param>
            <returns>The transformed direction in local space.</returns>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it. Specifies that an input argument was not null when the call returns.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
    </members>
</doc>
